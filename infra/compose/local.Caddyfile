{
	order request_body before cache
	order cache before reverse_proxy
	debug
}

:80 {
	# These matchers inspect the final response header AFTER it comes back from the reverse proxy.
	@cache_hit expression {http.response.header.Cache-Status}.matches("(?i).\\bhit\\b.")
	@cache_miss expression {http.response.header.Cache-Status}.matches("(?i).\\b(miss|stored)\\b.")
	@cache_bypass expression {http.response.header.Cache-Status}.matches("(?i).\\bbypass\\b.")

	reverse_proxy 127.0.0.1:18080 {
		header_up X-Auth-Cache-Key {http.request.header.Authorization}
		header_up -Authorization
		header_up Host {host}
		header_up X-Real-IP {remote_host}
		header_up +X-Forwarded-For {remote_host}
		header_up X-Forwarded-Proto {scheme}
	}

	# After the reverse_proxy is done, these header directives are evaluated
	# against the response, conditionally setting the normalized header.
	header @cache_hit X-Cache-Status HIT
	header @cache_miss X-Cache-Status MISS
	header @cache_bypass X-Cache-Status BYPASS
}

:18080 {
	route {
		# Make body available to placeholders
		request_body {
			max_size 10MB
		}


		# Put the raw body into a synthetic header for cache variance
		header {
		  request set X-Body {http.request.body}
		}

		cache {
		  allowed_http_verbs GET POST HEAD
		  ttl 1h
		  stale 24h

		  # Vary on auth AND the request body
		  headers X-Auth-Cache-Key X-Body

		  # Let the default key template handle method+URL; headers above add variance
		  # (no custom key template needed)
		}

		# If coming from :80 we have X-Auth-Cache-Key; restore it to Authorization
		@has_cache_key header_regexp X-Auth-Cache-Key .+
		handle @has_cache_key {
		  reverse_proxy host.containers.internal:8080 {
			header_up Authorization {http.request.header.X-Auth-Cache-Key}
			header_up -X-Auth-Cache-Key
			header_up -X-Body
			header_up Host {host}
			header_up X-Real-IP {remote_host}
			header_up +X-Forwarded-For {remote_host}
			header_up X-Forwarded-Proto {scheme}
		  }
		}

		# Fallback: if someone hits :18080 directly, still proxy through
		handle {
		  reverse_proxy host.containers.internal:8080 {
			header_up -X-Body
			header_up Host {host}
			header_up X-Real-IP {remote_host}
			header_up +X-Forwarded-For {remote_host}
			header_up X-Forwarded-Proto {scheme}
		  }
		}
	}
}