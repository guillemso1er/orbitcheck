{
	order request_body before cache
	order cache before reverse_proxy
	debug
}

:80 {
  # Serve static site files
  root * /usr/share/caddy/site
  try_files {path} {path}/ /index.html
  file_server

	# API routes
	@api {
		path /api/*
	}
	reverse_proxy @api 127.0.0.1:18080 {
		header_up X-Auth-Cache-Key {http.request.header.Authorization}
		header_up -Authorization
		header_up Host {host}
		header_up X-Real-IP {remote_host}
		header_up +X-Forwarded-For {remote_host}
		header_up X-Forwarded-Proto {scheme}
	}
}

:18080 {
	route {
		# Make body available to placeholders
		request_body {
			max_size 10MB
		}


		# Put the raw body into a synthetic header for cache variance
		header {
		  request set X-Body {http.request.body}
		}

		cache {
		  allowed_http_verbs GET POST HEAD
		  ttl 1h
		  stale 24h

		  # Vary on auth AND the request body
		  headers X-Auth-Cache-Key X-Body

		  # Let the default key template handle method+URL; headers above add variance
		  # (no custom key template needed)
		}

		# If coming from :80 we have X-Auth-Cache-Key; restore it to Authorization
		@has_cache_key header_regexp X-Auth-Cache-Key .+
		handle @has_cache_key {
		  reverse_proxy api:8080 {
			header_up Authorization {http.request.header.X-Auth-Cache-Key}
			header_up -X-Auth-Cache-Key
			header_up -X-Body
			header_up Host {host}
			header_up X-Real-IP {remote_host}
			header_up +X-Forwarded-For {remote_host}
			header_up X-Forwarded-Proto {scheme}
		  }
		}

		# Fallback: if someone hits :18080 directly, still proxy through
		handle {
		  reverse_proxy api:8080 {
			header_up -X-Body
			header_up Host {host}
			header_up X-Real-IP {remote_host}
			header_up +X-Forwarded-For {remote_host}
			header_up X-Forwarded-Proto {scheme}
		  }
		}
	}
}