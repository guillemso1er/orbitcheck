{
    # LetsEncrypt email (change to yours) test
    email guillemsoler@orbitcheck.io

    # Ensure the cache plugin runs before reverse proxy
    order request_body before cache
    order cache before reverse_proxy

    # Reduce header info leakage
    servers {
        # Uncomment to expose Prometheus metrics if you add the plugin
        # metrics
        trusted_proxies static private_ranges
        # If you’re behind ALB/Cloudflare/etc., also consider:
         trusted_proxies_strict
    }
}

# Shared security headers
(common_security_headers) {
    header {
        -Server
        X-Frame-Options DENY
        X-Content-Type-Options nosniff
        Referrer-Policy no-referrer-when-downgrade
        Permissions-Policy "geolocation=(), microphone=(), camera=(), fullscreen=*"
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
    }
    encode zstd gzip
}

# API public entrypoint
api.orbitcheck.io {
    import common_security_headers

    # Allow credentialed CORS only from the dashboard and site
    @cors_origin {
        header Origin https://dashboard.orbitcheck.io
        header Origin https://orbitcheck.io
        header Origin https://shopify.orbitcheck.io
        not method OPTIONS
    }
    header @cors_origin Access-Control-Allow-Origin "{http.request.header.Origin}"
    header @cors_origin Access-Control-Allow-Credentials "true"
    header @cors_origin Vary "Origin"

    # Preflight handler
    @preflight {
        method OPTIONS
        header Origin *
        header Access-Control-Request-Method *
    }
    handle @preflight {
        header Access-Control-Allow-Origin "{http.request.header.Origin}"
        header Access-Control-Allow-Credentials "true"
        header Access-Control-Allow-Methods "GET, POST, PUT, PATCH, DELETE, OPTIONS"
        header Access-Control-Allow-Headers "Content-Type, X-CSRF-Token"
        header Access-Control-Max-Age "3600"
        header Vary "Origin, Access-Control-Request-Method, Access-Control-Request-Headers"
        respond 204
    }

    reverse_proxy 127.0.0.1:18080 {
        header_up X-Forwarded-Proto {scheme}
        header_up Host {host}
        header_up X-Real-IP {remote_host}
        header_up +X-Forwarded-For {remote_host}
        # Do NOT strip Authorization; programmatic clients need it
        # header_up -Authorization   <-- remove this line if you had it
        trusted_proxies private_ranges
    }

    handle_errors {
        respond "{http.error.status_code} {http.error.status_text}"
    }
}

# Internal cache tier listener — loopback only
:18080 {
    bind 127.0.0.1

    route {
        request_body {
            max_size 10MB
        }

        @mutating method POST PUT PATCH DELETE
        @auth_paths path /auth/* /login /logout /session/*

        # Treat any of these as authenticated/private
        @auth_headers expression {http.request.header.Authorization} != "" || \
                                 {http.request.header.Cookie} != "" || \
                                 {http.request.header.X-API-Key} != "" || \
                                 {http.request.header.X-Api-Key} != "" || \
                                 {http.request.header.Signature} != ""

        # Never cache mutating, auth paths, or authenticated requests
        handle @mutating {
            reverse_proxy 127.0.0.1:8080 {
                header_up X-Forwarded-Proto {http.request.header.X-Forwarded-Proto}
                header_up Host {http.request.header.Host}
                transport http {
                    versions h2c 1.1
                }
            }
        }
        handle @auth_paths {
            reverse_proxy 127.0.0.1:8080 {
                header_up X-Forwarded-Proto {http.request.header.X-Forwarded-Proto}
                header_up Host {http.request.header.Host}
                transport http {
                    versions h2c 1.1
                }
            }
        }
        handle @auth_headers {
            reverse_proxy 127.0.0.1:8080 {
                header_up X-Forwarded-Proto {http.request.header.X-Forwarded-Proto}
                header_up Host {http.request.header.Host}
                transport http {
                    versions h2c 1.1
                }
            }
        }

        # Cache only anonymous GETs
        @anon_get {
            method GET
            not {
                expression {http.request.header.Authorization} != "" || \
                           {http.request.header.Cookie} != "" || \
                           {http.request.header.X-API-Key} != "" || \
                           {http.request.header.X-Api-Key} != "" || \
                           {http.request.header.Signature} != ""
                path /auth/* /login /logout /session/*
            }
        }
        handle @anon_get {
            cache {
                allowed_http_verbs GET
                ttl 2h
                stale 24h
            }
            reverse_proxy 127.0.0.1:8080 {
                header_up X-Forwarded-Proto {http.request.header.X-Forwarded-Proto}
                header_up Host {http.request.header.Host}
                transport http {
                    versions h2c 1.1
                }
            }
        }

        # Fallback (no cache)
        handle {
            reverse_proxy 127.0.0.1:8080 {
                header_up X-Forwarded-Proto {http.request.header.X-Forwarded-Proto}
                header_up Host {http.request.header.Host}
                transport http {
                    versions h2c 1.1
                }
            }
        }
    }
}

# Dashboard (React build)
dashboard.orbitcheck.io {
    import common_security_headers

    root * /usr/share/caddy
    encode zstd gzip

    # Long-lived cache for fingerprinted assets
    @immutable path_regexp immutable ^/(?:assets|static)/.*|.*\.(?:css|js|mjs|map|png|jpg|jpeg|gif|svg|webp|ico|woff2?|ttf|eot)$
    header @immutable Cache-Control "public, max-age=31536000, immutable"

    # Never cache HTML (ensures users get new deploys immediately)
    @html path_regexp html ^/(?:index\.html|.*\.html)$
    header @html Cache-Control "no-cache, no-store, must-revalidate"

    # SPA fallback to index.html
    try_files {path} /index.html
    file_server

    # Basic synthetic health endpoint
    @health path /.well-known/healthz
    respond @health 200

    log {
        output file /var/log/caddy/dashboard.orbitcheck.io.access.log {
            roll_size 100MiB
            roll_keep 10
            roll_keep_for 720h
        }
        format json
    }

    handle_errors {
        respond "{http.error.status_code} {http.error.status_text}"
    }
}


shopify.orbitcheck.io {
    import common_security_headers

    # Allow credentialed CORS only from the dashboard and site
    @cors_origin {
        header Origin https://dashboard.orbitcheck.io
        header Origin https://orbitcheck.io
        header Origin https://api.orbitcheck.io

        not method OPTIONS
    }
    header @cors_origin Access-Control-Allow-Origin "{http.request.header.Origin}"
    header @cors_origin Access-Control-Allow-Credentials "true"
    header @cors_origin Vary "Origin"

    # Preflight handler
    @preflight {
        method OPTIONS
        header Origin *
        header Access-Control-Request-Method *
    }
    handle @preflight {
        header Access-Control-Allow-Origin "{http.request.header.Origin}"
        header Access-Control-Allow-Credentials "true"
        header Access-Control-Allow-Methods "GET, POST, PUT, PATCH, DELETE, OPTIONS"
        header Access-Control-Allow-Headers "Content-Type, X-CSRF-Token"
        header Access-Control-Max-Age "3600"
        header Vary "Origin, Access-Control-Request-Method, Access-Control-Request-Headers"
        respond 204
    }

    reverse_proxy 127.0.0.1:3001 {
        header_up X-Forwarded-Proto {scheme}
        header_up Host {host}
        header_up X-Real-IP {remote_host}
        header_up +X-Forwarded-For {remote_host}
        trusted_proxies private_ranges
    }

    handle_errors {
        respond "{http.error.status_code} {http.error.status_text}"
    }
}