// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { BatchDedupeData, BatchDedupeErrors, BatchDedupeResponses, BatchEvaluateOrdersData, BatchEvaluateOrdersErrors, BatchEvaluateOrdersResponses, BatchValidateData, BatchValidateErrors, BatchValidateResponses, CheckValidationLimitsData, CheckValidationLimitsErrors, CheckValidationLimitsResponses, CreateApiKeyData, CreateApiKeyErrors, CreateApiKeyResponses, CreateCheckoutSessionData, CreateCheckoutSessionErrors, CreateCheckoutSessionResponses, CreateCustomerPortalSessionData, CreateCustomerPortalSessionErrors, CreateCustomerPortalSessionResponses, CreatePersonalAccessTokenData, CreatePersonalAccessTokenErrors, CreatePersonalAccessTokenResponses, CreateProjectData, CreateProjectErrors, CreateProjectResponses, CreateShopifyDashboardSessionData, CreateShopifyDashboardSessionErrors, CreateShopifyDashboardSessionResponses, CreateUserData, CreateUserErrors, CreateUserResponses, CreateWebhookData, CreateWebhookErrors, CreateWebhookResponses, DedupeAddressData, DedupeAddressErrors, DedupeAddressResponses, DedupeCustomerData, DedupeCustomerErrors, DedupeCustomerResponses, DeleteCustomRuleData, DeleteCustomRuleErrors, DeleteCustomRuleResponses, DeleteLogData, DeleteLogErrors, DeleteLogResponses, DeleteProjectData, DeleteProjectErrors, DeleteProjectResponses, DeleteWebhookData, DeleteWebhookErrors, DeleteWebhookResponses, EraseDataData, EraseDataErrors, EraseDataResponses, EstimateRoiData, EstimateRoiErrors, EstimateRoiResponses, EvaluateOrderData, EvaluateOrderErrors, EvaluateOrderResponses, GetAvailablePlansData, GetAvailablePlansErrors, GetAvailablePlansResponses, GetAvailableRulesData, GetAvailableRulesErrors, GetAvailableRulesResponses, GetBuiltInRulesData, GetBuiltInRulesErrors, GetBuiltInRulesResponses, GetErrorCodeCatalogData, GetErrorCodeCatalogErrors, GetErrorCodeCatalogResponses, GetJobStatusByIdData, GetJobStatusByIdErrors, GetJobStatusByIdResponses, GetLogsData, GetLogsErrors, GetLogsResponses, GetReasonCodeCatalogData, GetReasonCodeCatalogErrors, GetReasonCodeCatalogResponses, GetSettingsData, GetSettingsErrors, GetSettingsResponses, GetShopifyAccessScopesData, GetShopifyAccessScopesErrors, GetShopifyAccessScopesResponses, GetShopifyShopSettingsData, GetShopifyShopSettingsErrors, GetShopifyShopSettingsResponses, GetUsageData, GetUsageErrors, GetUsageResponses, GetUserPlanData, GetUserPlanErrors, GetUserPlanResponses, GetUserProjectsData, GetUserProjectsErrors, GetUserProjectsResponses, ListApiKeysData, ListApiKeysErrors, ListApiKeysResponses, ListPersonalAccessTokensData, ListPersonalAccessTokensErrors, ListPersonalAccessTokensResponses, ListUsersData, ListUsersErrors, ListUsersResponses, ListWebhooksData, ListWebhooksErrors, ListWebhooksResponses, LoginUserData, LoginUserErrors, LoginUserResponses, LogoutUserData, LogoutUserErrors, LogoutUserResponses, MergeDeduplicatedData, MergeDeduplicatedErrors, MergeDeduplicatedResponses, NormalizeAddressData, NormalizeAddressErrors, NormalizeAddressResponses, RegisterCustomRulesData, RegisterCustomRulesErrors, RegisterCustomRulesResponses, RegisterUserData, RegisterUserErrors, RegisterUserResponses, RevokeApiKeyData, RevokeApiKeyErrors, RevokeApiKeyResponses, RevokePersonalAccessTokenData, RevokePersonalAccessTokenErrors, RevokePersonalAccessTokenResponses, ShopifyAddressFixConfirmData, ShopifyAddressFixConfirmErrors, ShopifyAddressFixConfirmResponses, ShopifyAddressFixGetData, ShopifyAddressFixGetErrors, ShopifyAddressFixGetResponses, ShopifyAppInstalledEventData, ShopifyAppInstalledEventErrors, ShopifyAppInstalledEventResponses, ShopifyAppUninstalledWebhookData, ShopifyAppUninstalledWebhookErrors, ShopifyAppUninstalledWebhookResponses, ShopifyCallbackData, ShopifyCallbackErrors, ShopifyCallbackResponses, ShopifyCustomersCreateWebhookData, ShopifyCustomersCreateWebhookErrors, ShopifyCustomersCreateWebhookResponses, ShopifyCustomersUpdateWebhookData, ShopifyCustomersUpdateWebhookErrors, ShopifyCustomersUpdateWebhookResponses, ShopifyGdprCustomersDataRequestWebhookData, ShopifyGdprCustomersDataRequestWebhookErrors, ShopifyGdprCustomersDataRequestWebhookResponses, ShopifyGdprCustomersRedactWebhookData, ShopifyGdprCustomersRedactWebhookErrors, ShopifyGdprCustomersRedactWebhookResponses, ShopifyGdprShopRedactWebhookData, ShopifyGdprShopRedactWebhookErrors, ShopifyGdprShopRedactWebhookResponses, ShopifyInstallData, ShopifyInstallErrors, ShopifyInstallResponses, ShopifyOrdersCreateWebhookData, ShopifyOrdersCreateWebhookErrors, ShopifyOrdersCreateWebhookResponses, ShopifySsoData, ShopifySsoErrors, ShopifySsoResponses, TestRulesAgainstPayloadData, TestRulesAgainstPayloadErrors, TestRulesAgainstPayloadResponses, TestWebhookData, TestWebhookErrors, TestWebhookResponses, UpdateSettingsData, UpdateSettingsErrors, UpdateSettingsResponses, UpdateShopifyShopSettingsData, UpdateShopifyShopSettingsErrors, UpdateShopifyShopSettingsResponses, UpdateUserPlanData, UpdateUserPlanErrors, UpdateUserPlanResponses, ValidateAddressData, ValidateAddressErrors, ValidateAddressResponses, ValidateEmailData, ValidateEmailErrors, ValidateEmailResponses, ValidateNameData, ValidateNameErrors, ValidateNameResponses, ValidatePhoneData, ValidatePhoneErrors, ValidatePhoneResponses, ValidateTaxIdData, ValidateTaxIdErrors, ValidateTaxIdResponses, VerifyPhoneOtpData, VerifyPhoneOtpErrors, VerifyPhoneOtpResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * User login
 *
 * Authenticates user credentials, establishes server-side session with secure HttpOnly cookies, generates CSRF tokens for protection, and sets session duration based on rememberMe flag (7 days default, 30 days when enabled)
 */
export const loginUser = <ThrowOnError extends boolean = false>(options: Options<LoginUserData, ThrowOnError>) => {
    return (options.client ?? client).post<LoginUserResponses, LoginUserErrors, ThrowOnError>({
        url: '/auth/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Register new user
 *
 * Creates a new user account, assigns the default free plan, creates a default project, and establishes a server-side session with secure cookies for dashboard access
 */
export const registerUser = <ThrowOnError extends boolean = false>(options: Options<RegisterUserData, ThrowOnError>) => {
    return (options.client ?? client).post<RegisterUserResponses, RegisterUserErrors, ThrowOnError>({
        url: '/auth/register',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * User logout
 *
 * Logs out the current user by destroying the server-side session and clearing all authentication cookies (session, CSRF tokens)
 */
export const logoutUser = <ThrowOnError extends boolean = false>(options?: Options<LogoutUserData, ThrowOnError>) => {
    return (options?.client ?? client).post<LogoutUserResponses, LogoutUserErrors, ThrowOnError>({
        security: [
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            },
            {
                name: 'X-CSRF-Token',
                type: 'apiKey'
            }
        ],
        url: '/auth/logout',
        ...options
    });
};

/**
 * Shopify SSO entry point
 *
 * Accepts a one-time Shopify-issued token, creates a dashboard session, and redirects back to the OrbitCheck dashboard.
 */
export const shopifySso = <ThrowOnError extends boolean = false>(options: Options<ShopifySsoData, ThrowOnError>) => {
    return (options.client ?? client).get<ShopifySsoResponses, ShopifySsoErrors, ThrowOnError>({
        url: '/auth/shopify-sso',
        ...options
    });
};

/**
 * List API keys
 *
 * Retrieves all API keys associated with the authenticated project, ordered by creation date (newest first). Returns key metadata including ID, prefix, name, status, and usage timestamps.
 */
export const listApiKeys = <ThrowOnError extends boolean = false>(options?: Options<ListApiKeysData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListApiKeysResponses, ListApiKeysErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/api-keys',
        ...options
    });
};

/**
 * Create API key
 *
 * Generates a new API key for the authenticated project. Creates a cryptographically secure random key, encrypts and stores it securely in the database, and automatically creates a corresponding personal access token for internal use. The full key is returned only once for security reasons.
 */
export const createApiKey = <ThrowOnError extends boolean = false>(options: Options<CreateApiKeyData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateApiKeyResponses, CreateApiKeyErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/api-keys',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Revoke API key
 *
 * Revokes an API key by marking it as inactive. The key becomes unusable for authentication but remains in the database for audit purposes. This is a soft delete operation that changes the key's status to 'revoked'.
 */
export const revokeApiKey = <ThrowOnError extends boolean = false>(options: Options<RevokeApiKeyData, ThrowOnError>) => {
    return (options.client ?? client).delete<RevokeApiKeyResponses, RevokeApiKeyErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/api-keys/{id}',
        ...options
    });
};

/**
 * List webhooks
 *
 * Retrieves all webhooks for the authenticated project
 */
export const listWebhooks = <ThrowOnError extends boolean = false>(options?: Options<ListWebhooksData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListWebhooksResponses, ListWebhooksErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/webhooks',
        ...options
    });
};

/**
 * Create webhook
 *
 * Creates a new webhook subscription for the authenticated project
 */
export const createWebhook = <ThrowOnError extends boolean = false>(options: Options<CreateWebhookData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateWebhookResponses, CreateWebhookErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/webhooks',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete webhook
 *
 * Deletes a webhook subscription
 */
export const deleteWebhook = <ThrowOnError extends boolean = false>(options: Options<DeleteWebhookData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteWebhookResponses, DeleteWebhookErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/webhooks/{id}',
        ...options
    });
};

/**
 * Test Webhook
 *
 * Sends a sample payload to the provided webhook URL and returns the response. Useful for testing webhook configurations.
 */
export const testWebhook = <ThrowOnError extends boolean = false>(options: Options<TestWebhookData, ThrowOnError>) => {
    return (options.client ?? client).post<TestWebhookResponses, TestWebhookErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/webhooks/test',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get custom rules
 *
 * Retrieves a list of custom validation rules created by the user
 */
export const getAvailableRules = <ThrowOnError extends boolean = false>(options?: Options<GetAvailableRulesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAvailableRulesResponses, GetAvailableRulesErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/rules',
        ...options
    });
};

/**
 * Get builtin rules
 *
 * Retrieves a list of all built-in validation rules and their configurations
 */
export const getBuiltInRules = <ThrowOnError extends boolean = false>(options?: Options<GetBuiltInRulesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetBuiltInRulesResponses, GetBuiltInRulesErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/rules/builtin',
        ...options
    });
};

/**
 * Get error code catalog
 *
 * Retrieves a catalog of all possible error codes and their descriptions
 */
export const getErrorCodeCatalog = <ThrowOnError extends boolean = false>(options?: Options<GetErrorCodeCatalogData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetErrorCodeCatalogResponses, GetErrorCodeCatalogErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/rules/error-codes',
        ...options
    });
};

/**
 * Get reason code catalog
 *
 * Retrieves a catalog of all possible reason codes and their descriptions
 */
export const getReasonCodeCatalog = <ThrowOnError extends boolean = false>(options?: Options<GetReasonCodeCatalogData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetReasonCodeCatalogResponses, GetReasonCodeCatalogErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/rules/catalog',
        ...options
    });
};

/**
 * Test rules against payload
 *
 * Tests rules against a sample payload and returns triggered rules
 */
export const testRulesAgainstPayload = <ThrowOnError extends boolean = false>(options: Options<TestRulesAgainstPayloadData, ThrowOnError>) => {
    return (options.client ?? client).post<TestRulesAgainstPayloadResponses, TestRulesAgainstPayloadErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/rules/test',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Register custom rules
 *
 * Registers new custom validation rules for the project
 */
export const registerCustomRules = <ThrowOnError extends boolean = false>(options: Options<RegisterCustomRulesData, ThrowOnError>) => {
    return (options.client ?? client).post<RegisterCustomRulesResponses, RegisterCustomRulesErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/rules/register',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete custom rule
 *
 * Deletes a custom validation rule by its ID
 */
export const deleteCustomRule = <ThrowOnError extends boolean = false>(options: Options<DeleteCustomRuleData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteCustomRuleResponses, DeleteCustomRuleErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/rules/{id}',
        ...options
    });
};

/**
 * Validate email
 *
 * Validates an email address format using industry-standard parsing, checks for disposable email domain detection via Redis-backed database, performs DNS MX record validation with A/AAAA record fallback for domain verification, and provides normalized email format in lowercase ASCII. Results are cached for performance and include detailed validation reason codes.
 */
export const validateEmail = <ThrowOnError extends boolean = false>(options: Options<ValidateEmailData, ThrowOnError>) => {
    return (options.client ?? client).post<ValidateEmailResponses, ValidateEmailErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/validate/email',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Validate phone
 *
 * Validates and formats phone numbers to international E.164 standard using libphonenumber-js library. Supports country-specific validation rules and optional country hints for ambiguous numbers. Can initiate OTP (One-Time Password) verification via Twilio SMS when requested, returning verification SID for subsequent OTP confirmation. Results include normalized E.164 format and detailed reason codes.
 */
export const validatePhone = <ThrowOnError extends boolean = false>(options: Options<ValidatePhoneData, ThrowOnError>) => {
    return (options.client ?? client).post<ValidatePhoneResponses, ValidatePhoneErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/validate/phone',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Validate address
 *
 * Validates and normalizes a postal address comprehensively. Performs address parsing and standardization using libpostal, detects P.O. Box addresses, verifies postal code-city matching against GeoNames database, geocodes the address using LocationIQ/Nominatim with Google Maps fallback, and validates geographic coordinates are within country boundaries. Returns normalized address components, validation status, geocoding results, and detailed reason codes.
 */
export const validateAddress = <ThrowOnError extends boolean = false>(options: Options<ValidateAddressData, ThrowOnError>) => {
    return (options.client ?? client).post<ValidateAddressResponses, ValidateAddressErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/validate/address',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Validate tax ID
 *
 * Validates various tax identification numbers for different countries using format-specific algorithms and checksum validation. Supports Brazilian CPF/CNPJ, Mexican RFC, Argentine CUIT, Chilean RUT, Peruvian RUC, Colombian NIT, Spanish NIF/NIE/CIF, US EIN, and EU VAT numbers via VIES web service. Returns normalized format, validation status, and detailed reason codes indicating format or checksum errors.
 */
export const validateTaxId = <ThrowOnError extends boolean = false>(options: Options<ValidateTaxIdData, ThrowOnError>) => {
    return (options.client ?? client).post<ValidateTaxIdResponses, ValidateTaxIdErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/validate/tax-id',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Validate name
 *
 * Validates and normalizes a person's name string. Checks for valid length (1-100 characters), ensures only alphabetic characters, spaces, hyphens, apostrophes, and periods are used, and provides normalized formatting with detailed validation reason codes for any issues found.
 */
export const validateName = <ThrowOnError extends boolean = false>(options: Options<ValidateNameData, ThrowOnError>) => {
    return (options.client ?? client).post<ValidateNameResponses, ValidateNameErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/validate/name',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Evaluate order for risk and rules
 *
 * Evaluates an order for deduplication, validation, and applies business rules
 */
export const evaluateOrder = <ThrowOnError extends boolean = false>(options: Options<EvaluateOrderData, ThrowOnError>) => {
    return (options.client ?? client).post<EvaluateOrderResponses, EvaluateOrderErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/orders/evaluate',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Verify phone OTP
 *
 * Verifies OTP sent to phone number
 */
export const verifyPhoneOtp = <ThrowOnError extends boolean = false>(options: Options<VerifyPhoneOtpData, ThrowOnError>) => {
    return (options.client ?? client).post<VerifyPhoneOtpResponses, VerifyPhoneOtpErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/verify/phone',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get event logs
 *
 * Retrieves paginated event logs for the project with support for filtering by reason codes, API endpoints, and HTTP status codes. Results are ordered by creation time (newest first) and include pagination with cursor-based navigation for efficient retrieval of large datasets. Each log entry contains detailed information about API requests including timestamps, endpoints, response status, and associated metadata.
 *
 */
export const getLogs = <ThrowOnError extends boolean = false>(options?: Options<GetLogsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLogsResponses, GetLogsErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/data/logs',
        ...options
    });
};

/**
 * Get usage statistics
 *
 * Retrieves comprehensive usage statistics and analytics for the project including total validations and orders processed, daily breakdowns over the specified period, most frequent validation failure reason codes, and estimated cache hit ratio. Statistics cover the last 30 days by default and help monitor API usage patterns and system performance.
 *
 */
export const getUsage = <ThrowOnError extends boolean = false>(options?: Options<GetUsageData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUsageResponses, GetUsageErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/data/usage',
        ...options
    });
};

/**
 * Delete log entry
 *
 * Deletes a specific event log entry by its unique identifier. The operation ensures that only log entries belonging to the authenticated user's project can be deleted, providing secure access control for log management.
 *
 */
export const deleteLog = <ThrowOnError extends boolean = false>(options: Options<DeleteLogData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteLogResponses, DeleteLogErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/logs/{id}',
        ...options
    });
};

/**
 * List Personal Access Tokens
 *
 * Retrieves all personal access tokens associated with the authenticated user. Each token includes detailed metadata such as creation time, expiration date, access scopes, usage tracking (last used timestamp and IP), and current status. Tokens are ordered by creation date with the most recent first.
 *
 */
export const listPersonalAccessTokens = <ThrowOnError extends boolean = false>(options?: Options<ListPersonalAccessTokensData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListPersonalAccessTokensResponses, ListPersonalAccessTokensErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/pats',
        ...options
    });
};

/**
 * Create Personal Access Token
 *
 * Creates a new personal access token with configurable permissions and restrictions. The token can be scoped to specific API operations, environments (test/live), and optionally restricted to specific IP addresses or projects. If no expiration is specified, a default expiration period is applied. The full token value is returned only once upon creation and should be securely stored by the client.
 *
 */
export const createPersonalAccessToken = <ThrowOnError extends boolean = false>(options: Options<CreatePersonalAccessTokenData, ThrowOnError>) => {
    return (options.client ?? client).post<CreatePersonalAccessTokenResponses, CreatePersonalAccessTokenErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/pats',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Revoke Personal Access Token
 *
 * Revokes a personal access token by marking it as disabled. This prevents further use of the token while maintaining the token record for audit purposes. Only the token owner can revoke their own tokens, ensuring secure access control.
 *
 */
export const revokePersonalAccessToken = <ThrowOnError extends boolean = false>(options: Options<RevokePersonalAccessTokenData, ThrowOnError>) => {
    return (options.client ?? client).delete<RevokePersonalAccessTokenResponses, RevokePersonalAccessTokenErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/pats/{token_id}',
        ...options
    });
};

/**
 * Get tenant settings
 *
 * Retrieves the current tenant (project) settings including country-specific defaults, data formatting preferences, and risk assessment thresholds. If no custom settings have been configured, returns default empty configuration objects that can be used as a baseline for customization.
 *
 */
export const getSettings = <ThrowOnError extends boolean = false>(options?: Options<GetSettingsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSettingsResponses, GetSettingsErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/settings',
        ...options
    });
};

/**
 * Update tenant settings
 *
 * Updates tenant (project) settings for country defaults, formatting preferences, and risk thresholds. The operation performs an upsert - if settings don't exist they will be created, otherwise existing settings will be updated. All three setting categories are optional and can be updated independently.
 *
 */
export const updateSettings = <ThrowOnError extends boolean = false>(options: Options<UpdateSettingsData, ThrowOnError>) => {
    return (options.client ?? client).put<UpdateSettingsResponses, UpdateSettingsErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/settings',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Erase user data
 *
 * Initiates a comprehensive data erasure process for GDPR/CCPA compliance. Permanently deletes all project-related data including event logs, API keys, webhooks, settings, background jobs, personal access tokens, and audit logs. The user's account information is anonymized by replacing email and password with placeholder values. A confirmation email is sent to the user upon successful completion of the erasure process.
 *
 */
export const eraseData = <ThrowOnError extends boolean = false>(options: Options<EraseDataData, ThrowOnError>) => {
    return (options.client ?? client).post<EraseDataResponses, EraseDataErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/data/erase',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create Stripe Checkout session
 *
 * Creates a Stripe Checkout session for subscription billing. Calculates the total cost including the base plan and additional store addons based on the number of active stores beyond the included stores in the plan. The session supports promotion codes and redirects users to success/cancel URLs after payment completion.
 *
 */
export const createCheckoutSession = <ThrowOnError extends boolean = false>(options?: Options<CreateCheckoutSessionData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateCheckoutSessionResponses, CreateCheckoutSessionErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/billing/checkout',
        ...options
    });
};

/**
 * Create Stripe Customer Portal session
 *
 * Creates a Stripe Customer Portal session that allows customers to manage their billing information including subscription details, payment methods, billing history, and invoices. The portal is hosted by Stripe and provides a secure interface for customers to update their billing settings without requiring direct API access.
 *
 */
export const createCustomerPortalSession = <ThrowOnError extends boolean = false>(options?: Options<CreateCustomerPortalSessionData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateCustomerPortalSessionResponses, CreateCustomerPortalSessionErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/billing/portal',
        ...options
    });
};

/**
 * List users
 *
 * Retrieves a list of users in the project
 */
export const listUsers = <ThrowOnError extends boolean = false>(options?: Options<ListUsersData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListUsersResponses, ListUsersErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/users',
        ...options
    });
};

/**
 * Create user
 *
 * Creates a new user in the project
 */
export const createUser = <ThrowOnError extends boolean = false>(options: Options<CreateUserData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateUserResponses, CreateUserErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/users',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Normalize Address (Cheap)
 *
 * Performs basic address normalization without geocoding or external lookups
 */
export const normalizeAddress = <ThrowOnError extends boolean = false>(options: Options<NormalizeAddressData, ThrowOnError>) => {
    return (options.client ?? client).post<NormalizeAddressResponses, NormalizeAddressErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/normalize/address',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Install Shopify app
 *
 * Redirects user to Shopify OAuth installation flow
 */
export const shopifyInstall = <ThrowOnError extends boolean = false>(options: Options<ShopifyInstallData, ThrowOnError>) => {
    return (options.client ?? client).get<ShopifyInstallResponses, ShopifyInstallErrors, ThrowOnError>({
        url: '/integrations/shopify/auth/install',
        ...options
    });
};

/**
 * Shopify OAuth callback
 *
 * Handles Shopify OAuth callback and completes app installation
 */
export const shopifyCallback = <ThrowOnError extends boolean = false>(options: Options<ShopifyCallbackData, ThrowOnError>) => {
    return (options.client ?? client).get<ShopifyCallbackResponses, ShopifyCallbackErrors, ThrowOnError>({
        url: '/integrations/shopify/auth/callback',
        ...options
    });
};

/**
 * Get Shopify shop settings
 *
 * Retrieves the current Shopify shop mode setting
 */
export const getShopifyShopSettings = <ThrowOnError extends boolean = false>(options?: Options<GetShopifyShopSettingsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetShopifyShopSettingsResponses, GetShopifyShopSettingsErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/integrations/shopify/api/shop-settings',
        ...options
    });
};

/**
 * Update Shopify shop settings
 *
 * Updates the Shopify shop mode setting
 */
export const updateShopifyShopSettings = <ThrowOnError extends boolean = false>(options: Options<UpdateShopifyShopSettingsData, ThrowOnError>) => {
    return (options.client ?? client).post<UpdateShopifyShopSettingsResponses, UpdateShopifyShopSettingsErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/integrations/shopify/api/shop-settings',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Shopify access scopes
 *
 * Retrieves the current Shopify access scopes for the authenticated shop
 */
export const getShopifyAccessScopes = <ThrowOnError extends boolean = false>(options?: Options<GetShopifyAccessScopesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetShopifyAccessScopesResponses, GetShopifyAccessScopesErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/integrations/shopify/api/access-scopes',
        ...options
    });
};

/**
 * Shopify app installed event
 *
 * Registers a Shopify shop installation and stores its offline access token for future API calls.
 */
export const shopifyAppInstalledEvent = <ThrowOnError extends boolean = false>(options: Options<ShopifyAppInstalledEventData, ThrowOnError>) => {
    return (options.client ?? client).post<ShopifyAppInstalledEventResponses, ShopifyAppInstalledEventErrors, ThrowOnError>({
        url: '/integrations/shopify/events/app-installed',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create OrbitCheck dashboard session
 *
 * Creates an OrbitCheck dashboard session for a Shopify merchant, allowing them to access
 * the OrbitCheck dashboard with their Shopify account. This endpoint bridges Shopify embedded
 * app authentication to OrbitCheck session cookies.
 *
 */
export const createShopifyDashboardSession = <ThrowOnError extends boolean = false>(options?: Options<CreateShopifyDashboardSessionData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateShopifyDashboardSessionResponses, CreateShopifyDashboardSessionErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/integrations/shopify/events/dashboard-session',
        ...options
    });
};

/**
 * Shopify orders/create webhook
 *
 * Handles Shopify orders/create webhook events
 */
export const shopifyOrdersCreateWebhook = <ThrowOnError extends boolean = false>(options: Options<ShopifyOrdersCreateWebhookData, ThrowOnError>) => {
    return (options.client ?? client).post<ShopifyOrdersCreateWebhookResponses, ShopifyOrdersCreateWebhookErrors, ThrowOnError>({
        url: '/integrations/shopify/webhooks/orders-create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Shopify customers/create webhook
 *
 * Handles Shopify customers/create webhook events to sanitize and persist normalized customer addresses
 */
export const shopifyCustomersCreateWebhook = <ThrowOnError extends boolean = false>(options: Options<ShopifyCustomersCreateWebhookData, ThrowOnError>) => {
    return (options.client ?? client).post<ShopifyCustomersCreateWebhookResponses, ShopifyCustomersCreateWebhookErrors, ThrowOnError>({
        url: '/integrations/shopify/webhooks/customers-create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Shopify customers/update webhook
 *
 * Handles Shopify customers/update webhook events to refresh normalized customer addresses
 */
export const shopifyCustomersUpdateWebhook = <ThrowOnError extends boolean = false>(options: Options<ShopifyCustomersUpdateWebhookData, ThrowOnError>) => {
    return (options.client ?? client).post<ShopifyCustomersUpdateWebhookResponses, ShopifyCustomersUpdateWebhookErrors, ThrowOnError>({
        url: '/integrations/shopify/webhooks/customers-update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get address fix session by token
 *
 * Retrieves an address fix session for customer review via App Proxy
 */
export const shopifyAddressFixGet = <ThrowOnError extends boolean = false>(options: Options<ShopifyAddressFixGetData, ThrowOnError>) => {
    return (options.client ?? client).get<ShopifyAddressFixGetResponses, ShopifyAddressFixGetErrors, ThrowOnError>({
        url: '/integrations/shopify/address-fix/{token}',
        ...options
    });
};

/**
 * Confirm address fix selection
 *
 * Confirms customer's address selection and updates Shopify order
 */
export const shopifyAddressFixConfirm = <ThrowOnError extends boolean = false>(options: Options<ShopifyAddressFixConfirmData, ThrowOnError>) => {
    return (options.client ?? client).post<ShopifyAddressFixConfirmResponses, ShopifyAddressFixConfirmErrors, ThrowOnError>({
        url: '/integrations/shopify/address-fix/{token}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Shopify app/uninstalled webhook
 *
 * Handles Shopify app/uninstalled webhook events
 */
export const shopifyAppUninstalledWebhook = <ThrowOnError extends boolean = false>(options: Options<ShopifyAppUninstalledWebhookData, ThrowOnError>) => {
    return (options.client ?? client).post<ShopifyAppUninstalledWebhookResponses, ShopifyAppUninstalledWebhookErrors, ThrowOnError>({
        url: '/integrations/shopify/webhooks/app-uninstalled',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Shopify GDPR customers/data_request webhook
 *
 * Handles Shopify GDPR customers/data_request webhook events
 */
export const shopifyGdprCustomersDataRequestWebhook = <ThrowOnError extends boolean = false>(options: Options<ShopifyGdprCustomersDataRequestWebhookData, ThrowOnError>) => {
    return (options.client ?? client).post<ShopifyGdprCustomersDataRequestWebhookResponses, ShopifyGdprCustomersDataRequestWebhookErrors, ThrowOnError>({
        url: '/integrations/shopify/webhooks/gdpr/customers-data-request',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Shopify GDPR customers/redact webhook
 *
 * Handles Shopify GDPR customers/redact webhook events
 */
export const shopifyGdprCustomersRedactWebhook = <ThrowOnError extends boolean = false>(options: Options<ShopifyGdprCustomersRedactWebhookData, ThrowOnError>) => {
    return (options.client ?? client).post<ShopifyGdprCustomersRedactWebhookResponses, ShopifyGdprCustomersRedactWebhookErrors, ThrowOnError>({
        url: '/integrations/shopify/webhooks/gdpr/customers-redact',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Shopify GDPR shop/redact webhook
 *
 * Handles Shopify GDPR shop/redact webhook events
 */
export const shopifyGdprShopRedactWebhook = <ThrowOnError extends boolean = false>(options: Options<ShopifyGdprShopRedactWebhookData, ThrowOnError>) => {
    return (options.client ?? client).post<ShopifyGdprShopRedactWebhookResponses, ShopifyGdprShopRedactWebhookErrors, ThrowOnError>({
        url: '/integrations/shopify/webhooks/gdpr/shop-redact',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Deduplicate customer
 *
 * Searches for existing customers in your project using multiple matching strategies. Performs exact matching on normalized email and phone fields, plus fuzzy matching on customer names with similarity scoring. Returns potential duplicates with confidence scores and suggested actions for handling the matches.
 */
export const dedupeCustomer = <ThrowOnError extends boolean = false>(options: Options<DedupeCustomerData, ThrowOnError>) => {
    return (options.client ?? client).post<DedupeCustomerResponses, DedupeCustomerErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/dedupe/customer',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Deduplicate address
 *
 * Searches for existing addresses in your project using address normalization and multiple matching strategies. First normalizes the input address, then performs exact matching on address hashes, postal code combinations, and fuzzy matching on street addresses and cities. Returns potential duplicates with confidence scores and suggested actions.
 */
export const dedupeAddress = <ThrowOnError extends boolean = false>(options: Options<DedupeAddressData, ThrowOnError>) => {
    return (options.client ?? client).post<DedupeAddressResponses, DedupeAddressErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/dedupe/address',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Merge deduplicated records
 *
 * Consolidates multiple duplicate customer or address records into a single canonical record. Updates the database to mark the specified records as merged, setting their merged_to field to point to the canonical record. All specified IDs must belong to your project and the canonical record must be valid.
 */
export const mergeDeduplicated = <ThrowOnError extends boolean = false>(options: Options<MergeDeduplicatedData, ThrowOnError>) => {
    return (options.client ?? client).post<MergeDeduplicatedResponses, MergeDeduplicatedErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/dedupe/merge',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Batch validate data
 *
 * Performs asynchronous batch validation of emails, phones, addresses, or tax IDs. Creates a background job that processes the data and stores results for later retrieval. Maximum 10,000 items per request. Use the returned job_id to check status and retrieve results via the jobs endpoint.
 */
export const batchValidate = <ThrowOnError extends boolean = false>(options: Options<BatchValidateData, ThrowOnError>) => {
    return (options.client ?? client).post<BatchValidateResponses, BatchValidateErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/batch/validate',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Batch deduplicate data
 *
 * Performs asynchronous batch deduplication of multiple customers or addresses. Accepts an array of customer or address objects and processes them in the background using the same matching logic as individual dedupe endpoints. Creates a job that can be tracked via the jobs endpoint. Maximum 10,000 items per request. Results include match suggestions for each input item.
 */
export const batchDedupe = <ThrowOnError extends boolean = false>(options: Options<BatchDedupeData, ThrowOnError>) => {
    return (options.client ?? client).post<BatchDedupeResponses, BatchDedupeErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/batch/dedupe',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Batch evaluate orders
 *
 * Performs asynchronous batch evaluation of orders for risk assessment and rule validation. Creates a background job that analyzes each order against fraud detection rules and risk models, storing detailed results for later retrieval. Maximum 10,000 orders per request. Each order must include order_id and customer_email. Use the returned job_id to check status and retrieve results via the jobs endpoint.
 */
export const batchEvaluateOrders = <ThrowOnError extends boolean = false>(options: Options<BatchEvaluateOrdersData, ThrowOnError>) => {
    return (options.client ?? client).post<BatchEvaluateOrdersResponses, BatchEvaluateOrdersErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/batch/orders',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get job status
 *
 * Retrieves the status and results of an asynchronous batch job. Jobs are scoped to your project - you can only access jobs created by your project. Returns progress as a percentage calculated from processed vs total items. Result data is only included for completed jobs and varies by job type (validation results vs deduplication matches).
 */
export const getJobStatusById = <ThrowOnError extends boolean = false>(options: Options<GetJobStatusByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetJobStatusByIdResponses, GetJobStatusByIdErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                name: 'Signature-Input',
                type: 'apiKey'
            },
            {
                name: 'Signature',
                type: 'apiKey'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/v1/jobs/{id}',
        ...options
    });
};

/**
 * List user's projects
 *
 * Retrieves the list of projects for the authenticated user along with plan information
 */
export const getUserProjects = <ThrowOnError extends boolean = false>(options?: Options<GetUserProjectsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUserProjectsResponses, GetUserProjectsErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/projects',
        ...options
    });
};

/**
 * Create new project
 *
 * Creates a new project for the authenticated user
 */
export const createProject = <ThrowOnError extends boolean = false>(options: Options<CreateProjectData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateProjectResponses, CreateProjectErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/projects',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete project
 *
 * Deletes a project by ID for the authenticated user
 */
export const deleteProject = <ThrowOnError extends boolean = false>(options: Options<DeleteProjectData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteProjectResponses, DeleteProjectErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/projects/{id}',
        ...options
    });
};

/**
 * Get current user plan
 *
 * Retrieves the current plan and usage information for the authenticated user
 */
export const getUserPlan = <ThrowOnError extends boolean = false>(options?: Options<GetUserPlanData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUserPlanResponses, GetUserPlanErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/user/plan',
        ...options
    });
};

/**
 * Update user plan
 *
 * Updates the user's subscription plan
 */
export const updateUserPlan = <ThrowOnError extends boolean = false>(options: Options<UpdateUserPlanData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateUserPlanResponses, UpdateUserPlanErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/user/plan',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get available plans
 *
 * Returns all available subscription plans
 */
export const getAvailablePlans = <ThrowOnError extends boolean = false>(options?: Options<GetAvailablePlansData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAvailablePlansResponses, GetAvailablePlansErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/public/plans',
        ...options
    });
};

/**
 * Estimate ROI for Orbitcheck implementation
 *
 * Calculates potential monthly savings from implementing Orbitcheck based on order volume and default assumptions
 */
export const estimateRoi = <ThrowOnError extends boolean = false>(options: Options<EstimateRoiData, ThrowOnError>) => {
    return (options.client ?? client).post<EstimateRoiResponses, EstimateRoiErrors, ThrowOnError>({
        url: '/public/roi/estimate',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Check validation limits
 *
 * Checks if the user has enough validation quota remaining
 */
export const checkValidationLimits = <ThrowOnError extends boolean = false>(options: Options<CheckValidationLimitsData, ThrowOnError>) => {
    return (options.client ?? client).post<CheckValidationLimitsResponses, CheckValidationLimitsErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                in: 'cookie',
                name: 'sid',
                type: 'apiKey'
            }
        ],
        url: '/user/plan/usage/check',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
