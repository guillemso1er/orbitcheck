// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://api.orbitcheck.io/v1' | 'https://dev-api.orbitcheck.io/v1' | (string & {});
};

export type _Error = {
    error?: {
        /**
         * Error code
         */
        code?: string;
        /**
         * Error message
         */
        message?: string;
    };
    /**
     * Request identifier
     */
    request_id?: string;
};

export type ApiKey = {
    /**
     * API key ID
     */
    id?: string;
    /**
     * API key prefix (first 6 characters)
     */
    prefix?: string;
    /**
     * API key status
     */
    status?: 'active' | 'revoked';
    /**
     * Optional name for the API key
     */
    name?: string | null;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Last usage timestamp
     */
    last_used_at?: string | null;
};

export type Webhook = {
    /**
     * Webhook ID
     */
    id?: string;
    /**
     * Webhook URL
     */
    url?: string;
    /**
     * Events this webhook is subscribed to
     */
    events?: Array<string>;
    /**
     * Webhook status
     */
    status?: 'active' | 'inactive' | 'deleted';
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Last time webhook was fired
     */
    last_fired_at?: string | null;
};

export type Address = {
    /**
     * Street address line 1
     */
    line1?: string;
    /**
     * Street address line 2
     */
    line2?: string;
    /**
     * City
     */
    city?: string;
    /**
     * State or province
     */
    state?: string;
    /**
     * Postal code
     */
    postal_code?: string;
    /**
     * Two-letter country code
     */
    country?: string;
    /**
     * Latitude
     */
    lat?: number | null;
    /**
     * Longitude
     */
    lng?: number | null;
};

export type Customer = {
    /**
     * Customer email
     */
    email?: string;
    /**
     * Customer phone
     */
    phone?: string;
    /**
     * Customer first name
     */
    first_name?: string;
    /**
     * Customer last name
     */
    last_name?: string;
};

export type CustomerMatch = {
    /**
     * Customer ID
     */
    id?: string;
    /**
     * Similarity score (0-1)
     */
    similarity_score?: number;
    /**
     * Type of match
     */
    match_type?: 'exact_email' | 'exact_phone' | 'fuzzy_name';
    data?: {
        /**
         * Customer email
         */
        email?: string;
        /**
         * Customer phone
         */
        phone?: string;
        /**
         * Customer first name
         */
        first_name?: string;
        /**
         * Customer last name
         */
        last_name?: string;
    };
};

export type AddressMatch = {
    /**
     * Customer ID
     */
    id?: string;
    /**
     * Similarity score (0-1)
     */
    similarity_score?: number;
    /**
     * Type of match
     */
    match_type?: 'exact_email' | 'exact_phone' | 'fuzzy_name';
    data?: {
        /**
         * Customer email
         */
        email?: string;
        /**
         * Customer phone
         */
        phone?: string;
        /**
         * Customer first name
         */
        first_name?: string;
        /**
         * Customer last name
         */
        last_name?: string;
    };
};

export type DedupeResult = {
    matches?: Array<{
        id?: string;
        similarity_score?: number;
        match_type?: string;
        data?: {
            [key: string]: unknown;
        };
    }>;
    suggested_action?: 'create_new' | 'merge_with' | 'review';
    canonical_id?: string | null;
};

export type ValidationResult = {
    /**
     * Whether the validation passed
     */
    valid?: boolean;
    /**
     * List of reason codes
     */
    reason_codes?: Array<string>;
    /**
     * Whether the result is disposable (for email)
     */
    disposable?: boolean;
};

export type AddressValidationResult = {
    /**
     * Whether the address is valid
     */
    valid?: boolean;
    /**
     * List of reason codes
     */
    reason_codes?: Array<string>;
    /**
     * Whether the address is a P.O. Box
     */
    po_box?: boolean;
    /**
     * Whether postal code matches city
     */
    postal_city_match?: boolean;
    /**
     * Whether the address is within bounds
     */
    in_bounds?: boolean;
};

export type LogEntry = {
    /**
     * Log entry ID
     */
    id?: string;
    /**
     * Log entry type
     */
    type?: string;
    /**
     * API endpoint
     */
    endpoint?: string;
    /**
     * List of reason codes
     */
    reason_codes?: Array<string>;
    /**
     * HTTP status code
     */
    status?: number;
    /**
     * Additional metadata
     */
    meta?: {
        [key: string]: unknown;
    };
    /**
     * Creation timestamp
     */
    created_at?: string;
};

export type Rule = {
    /**
     * Rule ID
     */
    id?: string;
    /**
     * Rule name
     */
    name?: string;
    /**
     * Rule description
     */
    description?: string;
    /**
     * Rule category
     */
    category?: string;
    /**
     * Whether the rule is enabled
     */
    enabled?: boolean;
};

export type ReasonCode = {
    /**
     * Reason code
     */
    code?: string;
    /**
     * Description of the reason code
     */
    description?: string;
    /**
     * Category of the reason code
     */
    category?: string;
    /**
     * Severity level
     */
    severity?: 'low' | 'medium' | 'high';
};

export type ErrorCode = {
    /**
     * Error code
     */
    code?: string;
    /**
     * Description of the error code
     */
    description?: string;
    /**
     * Category of the error code
     */
    category?: string;
    /**
     * Severity level
     */
    severity?: 'low' | 'medium' | 'high';
};

export type CustomRule = {
    /**
     * Rule ID
     */
    id?: string;
    /**
     * Rule name
     */
    name?: string;
    /**
     * Rule description
     */
    description?: string;
    /**
     * Reason code to trigger
     */
    reason_code?: string;
    /**
     * Severity level
     */
    severity?: 'low' | 'medium' | 'high';
    /**
     * Whether the rule is enabled
     */
    enabled?: boolean;
};

export type UserPlanResponse = {
    /**
     * User ID
     */
    id?: string;
    /**
     * User email
     */
    email?: string;
    /**
     * Current plan details
     */
    plan?: {
        [key: string]: unknown;
    };
    /**
     * Number of validations used this month
     */
    monthlyValidationsUsed?: number;
    /**
     * Subscription status
     */
    subscriptionStatus?: string;
    /**
     * Trial end date if applicable
     */
    trialEndDate?: string | null;
    /**
     * Number of projects
     */
    projectsCount?: number;
};

export type UnauthorizedError = {
    code?: 'UNAUTHORIZED';
    /**
     * Error message
     */
    message?: string;
};

export type ValidationError = {
    error?: {
        code?: 'INVALID_INPUT' | 'INVALID_PLAN';
        /**
         * Error message
         */
        message?: string;
    };
};

export type NotFoundError = {
    error?: {
        code?: 'NOT_FOUND';
        /**
         * Error message
         */
        message?: string;
    };
};

export type LimitExceededError = {
    code?: 'LIMIT_EXCEEDED';
    /**
     * Error message
     */
    message?: string;
};

export type ServerError = {
    error?: {
        code?: 'INTERNAL_SERVER_ERROR';
        /**
         * Error message
         */
        message?: string;
    };
};

export type PersonalAccessToken = {
    /**
     * Token ID
     */
    id: string;
    /**
     * Public token identifier (last 4 chars shown)
     */
    token_id: string;
    /**
     * Token name
     */
    name: string;
    /**
     * Access scopes
     */
    scopes: Array<string>;
    /**
     * Environment
     */
    env: 'test' | 'live';
    /**
     * Last usage timestamp
     */
    last_used_at?: string | null;
    /**
     * Last usage IP
     */
    last_used_ip?: string | null;
    /**
     * Expiration date
     */
    expires_at?: string | null;
    /**
     * Whether token is disabled
     */
    disabled: boolean;
    /**
     * Creation timestamp
     */
    created_at: string;
};

export type RoiEstimateRequest = {
    /**
     * Number of orders processed per month
     */
    orders_per_month: number;
    /**
     * Rate of orders that have issues (default 0.021)
     */
    issue_rate?: number;
    /**
     * Share of issues that trigger carrier fees (default 0.5)
     */
    carrier_fee_share?: number;
    /**
     * Average carrier correction fee in USD (default 23.75)
     */
    avg_correction_fee?: number;
    /**
     * Share of issues that require reshipping (default 0.1)
     */
    reship_share?: number;
    /**
     * Cost of reshipping in USD (default 10)
     */
    reship_cost?: number;
    /**
     * Rate at which Orbitcheck prevents issues (default 0.5)
     */
    prevention_rate?: number;
    /**
     * Currency code (default USD)
     */
    currency?: string;
};

export type RoiEstimateResponse = {
    inputs?: {
        /**
         * Number of orders processed per month
         */
        orders_per_month?: number;
        /**
         * Rate of orders that have issues
         */
        issue_rate?: number;
        /**
         * Share of issues that trigger carrier fees
         */
        carrier_fee_share?: number;
        /**
         * Average carrier correction fee in USD
         */
        avg_correction_fee?: number;
        /**
         * Share of issues that require reshipping
         */
        reship_share?: number;
        /**
         * Cost of reshipping in USD
         */
        reship_cost?: number;
        /**
         * Rate at which Orbitcheck prevents issues
         */
        prevention_rate?: number;
        /**
         * Currency code
         */
        currency?: string;
    };
    estimates?: {
        /**
         * Estimated number of issues per month
         */
        issues_per_month?: number;
        /**
         * Average loss per issue in USD
         */
        loss_per_issue?: number;
        /**
         * Baseline monthly loss without Orbitcheck in USD
         */
        baseline_loss_per_month?: number;
        /**
         * Estimated monthly savings with Orbitcheck in USD
         */
        savings_per_month?: number;
    };
    meta?: {
        /**
         * Version of the ROI calculation model
         */
        model_version?: string;
        /**
         * Unique request identifier
         */
        request_id?: string;
    };
};

export type CreateUserRequest = {
    /**
     * User email address
     */
    email: string;
    /**
     * User first name
     */
    first_name: string;
    /**
     * User last name
     */
    last_name: string;
    /**
     * User password (optional for admin creation)
     */
    password?: string;
};

export type LoginRequest = {
    /**
     * User email address
     */
    email: string;
    /**
     * User password
     */
    password: string;
    /**
     * Whether to extend the session duration for longer-term login
     */
    rememberMe?: boolean;
};

export type LoginResponse = {
    user: {
        /**
         * User ID
         */
        id: string;
        /**
         * User email address
         */
        email: string;
        /**
         * User first name
         */
        first_name: string;
        /**
         * User last name
         */
        last_name: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
    /**
     * Request identifier
     */
    request_id?: string;
};

export type User = {
    /**
     * User ID
     */
    id: string;
    /**
     * User email address
     */
    email: string;
    /**
     * User first name
     */
    first_name: string;
    /**
     * User last name
     */
    last_name: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Last update timestamp
     */
    updated_at?: string;
};

export type Pagination = {
    /**
     * Current page number
     */
    page: number;
    /**
     * Number of items per page
     */
    limit: number;
    /**
     * Total number of items
     */
    total: number;
    /**
     * Total number of pages
     */
    total_pages: number;
};

export type LoginUserData = {
    body: {
        /**
         * User email address
         */
        email: string;
        /**
         * User password
         */
        password: string;
        /**
         * Whether to extend the session duration for longer-term login
         */
        rememberMe?: boolean;
    };
    path?: never;
    query?: never;
    url: '/auth/login';
};

export type LoginUserErrors = {
    /**
     * Invalid credentials
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Validation failed
     */
    422: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type LoginUserError = LoginUserErrors[keyof LoginUserErrors];

export type LoginUserResponses = {
    /**
     * Login successful; session established and cookie set
     */
    200: {
        user: {
            /**
             * User ID
             */
            id?: string;
            /**
             * User email
             */
            email?: string;
            /**
             * User first name
             */
            first_name?: string;
            /**
             * User last name
             */
            last_name?: string;
            created_at?: string;
            updated_at?: string;
        };
        /**
         * Request identifier
         */
        request_id: string;
    };
};

export type LoginUserResponse = LoginUserResponses[keyof LoginUserResponses];

export type RegisterUserData = {
    body: {
        /**
         * User email address
         */
        email: string;
        /**
         * User password (minimum 8 characters)
         */
        password: string;
        /**
         * Confirm password (must match password)
         */
        confirm_password: string;
    };
    path?: never;
    query?: never;
    url: '/auth/register';
};

export type RegisterUserErrors = {
    /**
     * Invalid input data
     */
    400: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * User already exists
     */
    409: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Validation failed
     */
    422: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type RegisterUserError = RegisterUserErrors[keyof RegisterUserErrors];

export type RegisterUserResponses = {
    /**
     * User registered successfully
     */
    201: {
        /**
         * JWT authentication token
         */
        token?: string;
        user?: {
            /**
             * User ID
             */
            id?: string;
            /**
             * User email
             */
            email?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type RegisterUserResponse = RegisterUserResponses[keyof RegisterUserResponses];

export type LogoutUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/logout';
};

export type LogoutUserErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Validation failed
     */
    422: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type LogoutUserError = LogoutUserErrors[keyof LogoutUserErrors];

export type LogoutUserResponses = {
    /**
     * Logout successful
     */
    200: {
        /**
         * Success message
         */
        message?: string;
    };
};

export type LogoutUserResponse = LogoutUserResponses[keyof LogoutUserResponses];

export type ListApiKeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/api-keys';
};

export type ListApiKeysErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type ListApiKeysError = ListApiKeysErrors[keyof ListApiKeysErrors];

export type ListApiKeysResponses = {
    /**
     * List of API keys for the project
     */
    200: {
        data?: Array<{
            /**
             * API key ID
             */
            id?: string;
            /**
             * API key prefix (first 6 characters)
             */
            prefix?: string;
            /**
             * API key status
             */
            status?: 'active' | 'revoked';
            /**
             * Optional name for the API key
             */
            name?: string | null;
            /**
             * Creation timestamp
             */
            created_at?: string;
            /**
             * Last usage timestamp
             */
            last_used_at?: string | null;
        }>;
        request_id?: string;
    };
};

export type ListApiKeysResponse = ListApiKeysResponses[keyof ListApiKeysResponses];

export type CreateApiKeyData = {
    body: {
        /**
         * Optional human-readable name for the API key
         */
        name?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/api-keys';
};

export type CreateApiKeyErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type CreateApiKeyError = CreateApiKeyErrors[keyof CreateApiKeyErrors];

export type CreateApiKeyResponses = {
    /**
     * API key created successfully
     */
    201: {
        /**
         * Unique identifier for the API key
         */
        id?: string;
        /**
         * API key prefix (first 6 characters) for identification
         */
        prefix?: string;
        /**
         * The complete API key (returned only once for security)
         */
        full_key?: string;
        /**
         * API key status (always 'active' for new keys)
         */
        status?: 'active';
        /**
         * Creation timestamp
         */
        created_at?: string;
        request_id?: string;
    };
};

export type CreateApiKeyResponse = CreateApiKeyResponses[keyof CreateApiKeyResponses];

export type RevokeApiKeyData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the API key to revoke
         */
        id: string;
    };
    query?: never;
    url: '/v1/api-keys/{id}';
};

export type RevokeApiKeyErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * API key not found or does not belong to the authenticated project
     */
    404: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type RevokeApiKeyError = RevokeApiKeyErrors[keyof RevokeApiKeyErrors];

export type RevokeApiKeyResponses = {
    /**
     * API key revoked successfully
     */
    200: {
        /**
         * API key ID that was revoked
         */
        id?: string;
        /**
         * Updated status of the API key (always 'revoked')
         */
        status?: 'revoked';
        request_id?: string;
    };
};

export type RevokeApiKeyResponse = RevokeApiKeyResponses[keyof RevokeApiKeyResponses];

export type ListWebhooksData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/webhooks';
};

export type ListWebhooksErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type ListWebhooksError = ListWebhooksErrors[keyof ListWebhooksErrors];

export type ListWebhooksResponses = {
    /**
     * List of webhooks
     */
    200: {
        data?: Array<{
            id?: string;
            url?: string;
            events?: Array<string>;
            status?: 'active' | 'inactive' | 'deleted';
            created_at?: string;
            last_fired_at?: string | null;
        }>;
        request_id?: string;
    };
};

export type ListWebhooksResponse = ListWebhooksResponses[keyof ListWebhooksResponses];

export type CreateWebhookData = {
    body: {
        /**
         * The webhook URL to send events to
         */
        url: string;
        /**
         * Events to subscribe to
         */
        events: Array<string>;
        /**
         * Secret used to sign webhook payloads
         */
        secret?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/webhooks';
};

export type CreateWebhookErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type CreateWebhookError = CreateWebhookErrors[keyof CreateWebhookErrors];

export type CreateWebhookResponses = {
    /**
     * Webhook created successfully
     */
    201: {
        id?: string;
        url?: string;
        events?: Array<string>;
        secret?: string;
        status?: string;
        created_at?: string;
        request_id?: string;
    };
};

export type CreateWebhookResponse = CreateWebhookResponses[keyof CreateWebhookResponses];

export type DeleteWebhookData = {
    body?: never;
    path: {
        /**
         * ID of the webhook to delete
         */
        id: string;
    };
    query?: never;
    url: '/v1/webhooks/{id}';
};

export type DeleteWebhookErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Webhook not found
     */
    404: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type DeleteWebhookError = DeleteWebhookErrors[keyof DeleteWebhookErrors];

export type DeleteWebhookResponses = {
    /**
     * Webhook deleted successfully
     */
    200: {
        id?: string;
        status?: string;
        request_id?: string;
    };
};

export type DeleteWebhookResponse = DeleteWebhookResponses[keyof DeleteWebhookResponses];

export type TestWebhookData = {
    body: {
        /**
         * The webhook URL to send the payload to
         */
        url: string;
        /**
         * Type of sample payload to send
         */
        payload_type: 'validation' | 'order' | 'custom';
        /**
         * Custom payload if payload_type is "custom"
         */
        custom_payload?: {
            [key: string]: unknown;
        };
    };
    path?: never;
    query?: never;
    url: '/v1/webhooks/test';
};

export type TestWebhookErrors = {
    /**
     * Bad request
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Rate limit exceeded
     */
    429: {
        code?: 'LIMIT_EXCEEDED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type TestWebhookError = TestWebhookErrors[keyof TestWebhookErrors];

export type TestWebhookResponses = {
    /**
     * Webhook test result
     */
    200: {
        sent_to?: string;
        payload?: {
            [key: string]: unknown;
        };
        response?: {
            status?: number;
            status_text?: string;
            headers?: {
                [key: string]: unknown;
            };
            body?: string;
        };
        request_id?: string;
    };
};

export type TestWebhookResponse = TestWebhookResponses[keyof TestWebhookResponses];

export type GetAvailableRulesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/rules';
};

export type GetAvailableRulesErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type GetAvailableRulesError = GetAvailableRulesErrors[keyof GetAvailableRulesErrors];

export type GetAvailableRulesResponses = {
    /**
     * List of custom rules
     */
    200: {
        rules?: Array<{
            /**
             * Rule identifier
             */
            id?: string;
            /**
             * Human-readable rule name
             */
            name?: string;
            /**
             * Rule description
             */
            description?: string;
            /**
             * Rule category
             */
            category?: string;
            /**
             * Rule severity level
             */
            severity?: 'low' | 'medium' | 'high' | 'critical';
            /**
             * Whether the rule is enabled
             */
            enabled?: boolean;
            /**
             * Rule configuration options
             */
            config?: {
                [key: string]: unknown;
            };
            /**
             * Rule condition expression
             */
            condition?: string;
        }>;
        request_id?: string;
    };
};

export type GetAvailableRulesResponse = GetAvailableRulesResponses[keyof GetAvailableRulesResponses];

export type GetBuiltInRulesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/rules/builtin';
};

export type GetBuiltInRulesErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type GetBuiltInRulesError = GetBuiltInRulesErrors[keyof GetBuiltInRulesErrors];

export type GetBuiltInRulesResponses = {
    /**
     * List of builtin rules
     */
    200: {
        rules?: Array<{
            /**
             * Rule identifier
             */
            id?: string;
            /**
             * Human-readable rule name
             */
            name?: string;
            /**
             * Rule description
             */
            description?: string;
            /**
             * Rule category
             */
            category?: string;
            /**
             * Rule severity level
             */
            severity?: 'low' | 'medium' | 'high' | 'critical';
            /**
             * Whether the rule is enabled
             */
            enabled?: boolean;
            /**
             * Rule configuration options
             */
            config?: {
                [key: string]: unknown;
            };
            /**
             * Rule condition expression
             */
            condition?: string;
        }>;
        request_id?: string;
    };
};

export type GetBuiltInRulesResponse = GetBuiltInRulesResponses[keyof GetBuiltInRulesResponses];

export type GetErrorCodeCatalogData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/rules/error-codes';
};

export type GetErrorCodeCatalogErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type GetErrorCodeCatalogError = GetErrorCodeCatalogErrors[keyof GetErrorCodeCatalogErrors];

export type GetErrorCodeCatalogResponses = {
    /**
     * Error code catalog
     */
    200: {
        error_codes?: Array<{
            /**
             * Error code
             */
            code?: string;
            /**
             * Error description
             */
            description?: string;
            /**
             * Error category
             */
            category?: string;
            /**
             * Error severity level
             */
            severity?: 'low' | 'medium' | 'high' | 'critical';
        }>;
        request_id?: string;
    };
};

export type GetErrorCodeCatalogResponse = GetErrorCodeCatalogResponses[keyof GetErrorCodeCatalogResponses];

export type GetReasonCodeCatalogData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/rules/catalog';
};

export type GetReasonCodeCatalogErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type GetReasonCodeCatalogError = GetReasonCodeCatalogErrors[keyof GetReasonCodeCatalogErrors];

export type GetReasonCodeCatalogResponses = {
    /**
     * Reason code catalog
     */
    200: {
        reason_codes?: Array<{
            /**
             * Reason code
             */
            code?: string;
            /**
             * Reason description
             */
            description?: string;
            /**
             * Reason category
             */
            category?: string;
            /**
             * Reason severity
             */
            severity?: 'info' | 'warning' | 'error';
        }>;
        request_id?: string;
    };
};

export type GetReasonCodeCatalogResponse = GetReasonCodeCatalogResponses[keyof GetReasonCodeCatalogResponses];

export type TestRulesAgainstPayloadData = {
    body: {
        /**
         * Sample payload to test rules against
         */
        payload: {
            [key: string]: unknown;
        };
        /**
         * Optional list of specific rule IDs to test
         */
        rule_ids?: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/v1/rules/test';
};

export type TestRulesAgainstPayloadErrors = {
    /**
     * Bad request
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Rate limit exceeded
     */
    429: {
        code?: 'LIMIT_EXCEEDED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type TestRulesAgainstPayloadError = TestRulesAgainstPayloadErrors[keyof TestRulesAgainstPayloadErrors];

export type TestRulesAgainstPayloadResponses = {
    /**
     * Rule test results
     */
    200: {
        /**
         * Validation results for each field
         */
        results?: {
            email?: {
                valid?: boolean;
                confidence?: number;
                reason_codes?: Array<string>;
                risk_score?: number;
                processing_time_ms?: number;
                provider?: string;
                normalized?: string;
                disposable?: boolean;
                domain_reputation?: number;
                mx_records?: boolean;
                smtp_check?: boolean;
                catch_all?: boolean;
                role_account?: boolean;
                free_provider?: boolean;
                domain?: string;
                metadata?: {
                    [key: string]: unknown;
                };
            };
            phone?: {
                valid?: boolean;
                confidence?: number;
                reason_codes?: Array<string>;
                risk_score?: number;
                processing_time_ms?: number;
                provider?: string;
                e164?: string;
                country?: string;
                carrier?: string;
                line_type?: string;
                reachable?: boolean;
                ported?: boolean;
                roaming?: boolean;
                metadata?: {
                    [key: string]: unknown;
                };
            };
            address?: {
                valid?: boolean;
                confidence?: number;
                reason_codes?: Array<string>;
                risk_score?: number;
                processing_time_ms?: number;
                provider?: string;
                normalized?: {
                    [key: string]: unknown;
                };
                po_box?: boolean;
                residential?: boolean;
                deliverable?: boolean;
                dpv_confirmed?: boolean;
                geocode?: {
                    lat?: number;
                    lng?: number;
                };
                postal_code_mismatch?: boolean;
                city?: string;
                postal_code?: string;
                metadata?: {
                    [key: string]: unknown;
                };
            };
            name?: {
                valid?: boolean;
                confidence?: number;
                reason_codes?: Array<string>;
                risk_score?: number;
                processing_time_ms?: number;
                provider?: string;
                normalized?: string;
                parts?: {
                    first?: string;
                    middle?: string;
                    last?: string;
                };
                gender?: string;
                salutation?: string;
                metadata?: {
                    [key: string]: unknown;
                };
            };
            ip?: {
                valid?: boolean;
                confidence?: number;
                reason_codes?: Array<string>;
                risk_score?: number;
                processing_time_ms?: number;
                provider?: string;
                country?: string;
                region?: string;
                city?: string;
                is_vpn?: boolean;
                is_proxy?: boolean;
                is_tor?: boolean;
                is_datacenter?: boolean;
                asn?: string;
                org?: string;
                metadata?: {
                    [key: string]: unknown;
                };
            };
            device?: {
                valid?: boolean;
                confidence?: number;
                reason_codes?: Array<string>;
                risk_score?: number;
                processing_time_ms?: number;
                provider?: string;
                type?: string;
                os?: string;
                browser?: string;
                is_bot?: boolean;
                fingerprint?: string;
                metadata?: {
                    [key: string]: unknown;
                };
            };
        };
        rule_evaluations?: Array<{
            /**
             * ID of the rule
             */
            rule_id?: string;
            /**
             * Name of the rule
             */
            rule_name?: string;
            /**
             * Rule description
             */
            description?: string;
            /**
             * Rule condition/logic
             */
            condition?: string;
            /**
             * Whether the rule was triggered
             */
            triggered?: boolean;
            /**
             * Action to take if triggered
             */
            action?: 'approve' | 'hold' | 'block';
            /**
             * Rule priority
             */
            priority?: number;
            /**
             * Time taken to evaluate the rule
             */
            evaluation_time_ms?: number;
            /**
             * Confidence score of the evaluation
             */
            confidence_score?: number;
            /**
             * Reason for the evaluation result
             */
            reason?: string;
            /**
             * Error message if evaluation failed
             */
            error?: string;
            metadata?: {
                [key: string]: unknown;
            };
        }>;
        final_decision?: {
            /**
             * Final action to take
             */
            action?: 'approve' | 'hold' | 'block' | 'review';
            /**
             * Confidence in the decision
             */
            confidence?: number;
            /**
             * Reasons for the decision
             */
            reasons?: Array<string>;
            /**
             * Overall risk score
             */
            risk_score?: number;
            /**
             * Risk level
             */
            risk_level?: 'low' | 'medium' | 'high' | 'critical';
            /**
             * Recommended actions to take
             */
            recommended_actions?: Array<string>;
        };
        performance_metrics?: {
            /**
             * Total request duration
             */
            total_duration_ms?: number;
            /**
             * Validation duration
             */
            validation_duration_ms?: number;
            /**
             * Rule evaluation duration
             */
            rule_evaluation_duration_ms?: number;
            /**
             * Whether validations were run in parallel
             */
            parallel_validations?: boolean;
            /**
             * Number of cache hits
             */
            cache_hits?: number;
            /**
             * Number of cache misses
             */
            cache_misses?: number;
        };
        /**
         * Request identifier
         */
        request_id?: string;
        /**
         * Response timestamp
         */
        timestamp?: string;
        /**
         * Project identifier
         */
        project_id?: string;
        /**
         * Environment
         */
        environment?: 'test' | 'production';
        /**
         * Debug information (only when X-Debug header is set)
         */
        debug_info?: {
            /**
             * Number of rules evaluated
             */
            rules_evaluated?: number;
            /**
             * Number of rules triggered
             */
            rules_triggered?: number;
            /**
             * Validation providers used
             */
            validation_providers_used?: Array<string>;
            /**
             * Errors encountered
             */
            errors?: Array<{
                field?: string;
                error?: string;
            }>;
            /**
             * Warnings encountered
             */
            warnings?: Array<string>;
        };
    };
};

export type TestRulesAgainstPayloadResponse = TestRulesAgainstPayloadResponses[keyof TestRulesAgainstPayloadResponses];

export type RegisterCustomRulesData = {
    body: {
        /**
         * Array of custom rules to register
         */
        rules: Array<{
            /**
             * Optional rule ID (UUID format). If provided, will update existing rule if found.
             */
            id?: string;
            /**
             * Custom rule name
             */
            name: string;
            /**
             * Rule description
             */
            description?: string;
            /**
             * A string containing the rule's logic expression.
             */
            condition?: string;
            /**
             * A string containing the rule's logic expression (alias for condition).
             */
            logic?: string;
            /**
             * A structured JSON object defining the rule's logic.
             */
            conditions?: {
                [key: string]: unknown;
            };
            /**
             * Rule severity
             */
            severity?: 'low' | 'medium' | 'high' | 'critical';
            /**
             * Whether the rule is enabled
             */
            enabled?: boolean;
            /**
             * Action to take when the rule is triggered
             */
            action?: 'approve' | 'hold' | 'block';
            /**
             * Actions object (legacy format)
             */
            actions?: {
                block?: boolean;
                approve?: boolean;
                hold?: boolean;
            };
            /**
             * Rule priority (higher values = higher priority)
             */
            priority?: number;
            /**
             * Additional metadata for the rule
             */
            metadata?: {
                [key: string]: unknown;
            };
        }>;
    };
    path?: never;
    query?: never;
    url: '/v1/rules/register';
};

export type RegisterCustomRulesErrors = {
    /**
     * Invalid rule definitions
     */
    400: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type RegisterCustomRulesError = RegisterCustomRulesErrors[keyof RegisterCustomRulesErrors];

export type RegisterCustomRulesResponses = {
    /**
     * Custom rules registered successfully
     */
    201: {
        /**
         * Success message
         */
        message?: string;
        /**
         * List of updated rule IDs
         */
        updated_rules?: Array<string>;
        /**
         * List of newly created rule IDs
         */
        registered_rules?: Array<string>;
        request_id?: string;
    };
};

export type RegisterCustomRulesResponse = RegisterCustomRulesResponses[keyof RegisterCustomRulesResponses];

export type DeleteCustomRuleData = {
    body?: never;
    path: {
        /**
         * ID of the custom rule to delete
         */
        id: string;
    };
    query?: never;
    url: '/v1/rules/{id}';
};

export type DeleteCustomRuleErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Custom rule not found
     */
    404: {
        /**
         * Error message
         */
        error?: string;
        /**
         * Request identifier
         */
        request_id?: string;
        /**
         * Additional error details
         */
        details?: string;
    };
};

export type DeleteCustomRuleError = DeleteCustomRuleErrors[keyof DeleteCustomRuleErrors];

export type DeleteCustomRuleResponses = {
    /**
     * Custom rule deleted successfully
     */
    200: {
        /**
         * Success message
         */
        message?: string;
        /**
         * ID of the deleted rule
         */
        deleted_rule_id?: string;
        request_id?: string;
    };
};

export type DeleteCustomRuleResponse = DeleteCustomRuleResponses[keyof DeleteCustomRuleResponses];

export type ValidateEmailData = {
    body: {
        /**
         * Email address to validate
         */
        email: string;
    };
    path?: never;
    query?: never;
    url: '/v1/validate/email';
};

export type ValidateEmailErrors = {
    /**
     * Bad request
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
    /**
     * Rate limit exceeded
     */
    429: {
        code?: 'LIMIT_EXCEEDED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type ValidateEmailError = ValidateEmailErrors[keyof ValidateEmailErrors];

export type ValidateEmailResponses = {
    /**
     * Email validation result
     */
    200: {
        /**
         * Whether the email is valid
         */
        valid?: boolean;
        /**
         * Normalized email address
         */
        normalized?: string;
        /**
         * Whether the email is disposable
         */
        disposable?: boolean;
        /**
         * Whether MX records were found
         */
        mx_found?: boolean;
        /**
         * List of reason codes
         */
        reason_codes?: Array<string>;
        request_id?: string;
        /**
         * Time to live in seconds
         */
        ttl_seconds?: number;
    };
};

export type ValidateEmailResponse = ValidateEmailResponses[keyof ValidateEmailResponses];

export type ValidatePhoneData = {
    body: {
        /**
         * Phone number to validate
         */
        phone: string;
        /**
         * ISO 3166-1 alpha-2 country code
         */
        country?: string;
        /**
         * Whether to request an OTP for phone verification
         */
        request_otp?: boolean;
    };
    path?: never;
    query?: never;
    url: '/v1/validate/phone';
};

export type ValidatePhoneErrors = {
    /**
     * Bad request
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
    /**
     * Rate limit exceeded
     */
    429: {
        code?: 'LIMIT_EXCEEDED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type ValidatePhoneError = ValidatePhoneErrors[keyof ValidatePhoneErrors];

export type ValidatePhoneResponses = {
    /**
     * Phone validation result
     */
    200: {
        /**
         * Whether the phone is valid
         */
        valid?: boolean;
        /**
         * E.164 formatted phone number
         */
        e164?: string;
        /**
         * ISO 3166-1 alpha-2 country code
         */
        country?: string;
        /**
         * List of reason codes
         */
        reason_codes?: Array<string>;
        request_id?: string;
        /**
         * Time to live in seconds
         */
        ttl_seconds?: number;
        /**
         * Twilio verification SID when OTP is requested
         */
        verification_sid?: string;
    };
};

export type ValidatePhoneResponse = ValidatePhoneResponses[keyof ValidatePhoneResponses];

export type ValidateAddressData = {
    body: {
        address: {
            /**
             * Street address line 1
             */
            line1: string;
            /**
             * Street address line 2
             */
            line2?: string;
            /**
             * City
             */
            city: string;
            /**
             * State or province
             */
            state?: string;
            /**
             * Postal code
             */
            postal_code: string;
            /**
             * Two-letter country code
             */
            country: string;
        };
    };
    path?: never;
    query?: never;
    url: '/v1/validate/address';
};

export type ValidateAddressErrors = {
    /**
     * Bad request
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
    /**
     * Rate limit exceeded
     */
    429: {
        code?: 'LIMIT_EXCEEDED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type ValidateAddressError = ValidateAddressErrors[keyof ValidateAddressErrors];

export type ValidateAddressResponses = {
    /**
     * Address validation result
     */
    200: {
        /**
         * Whether the address is valid
         */
        valid?: boolean;
        /**
         * Normalized address object
         */
        normalized?: {
            line1?: string;
            line2?: string;
            city?: string;
            state?: string;
            postal_code?: string;
            country?: string;
        };
        /**
         * List of reason codes
         */
        reason_codes?: Array<string>;
        /**
         * Whether the address is a P.O. Box
         */
        po_box?: boolean;
        /**
         * Whether postal code matches city
         */
        postal_city_match?: boolean;
        /**
         * Whether the address is within bounds
         */
        in_bounds?: boolean;
        request_id?: string;
        /**
         * Time to live in seconds
         */
        ttl_seconds?: number;
    };
};

export type ValidateAddressResponse = ValidateAddressResponses[keyof ValidateAddressResponses];

export type ValidateTaxIdData = {
    body: {
        /**
         * Type of tax ID (e.g., "vat", "euvat", "br_cnpj")
         */
        type: string;
        /**
         * The tax ID number
         */
        value: string;
        /**
         * Optional two-letter country code
         */
        country?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/validate/tax-id';
};

export type ValidateTaxIdErrors = {
    /**
     * Validation error
     */
    400: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type ValidateTaxIdError = ValidateTaxIdErrors[keyof ValidateTaxIdErrors];

export type ValidateTaxIdResponses = {
    /**
     * Tax ID validation result
     */
    200: {
        /**
         * Whether the tax ID is valid
         */
        valid?: boolean;
        /**
         * Normalized tax ID
         */
        normalized?: string;
        /**
         * Type of tax ID
         */
        type?: string;
        /**
         * List of validation reason codes
         */
        reason_codes?: Array<string>;
        request_id?: string;
        /**
         * Time to live in seconds
         */
        ttl_seconds?: number;
    };
};

export type ValidateTaxIdResponse = ValidateTaxIdResponses[keyof ValidateTaxIdResponses];

export type ValidateNameData = {
    body: {
        /**
         * The name to validate and normalize
         */
        name: string;
    };
    path?: never;
    query?: never;
    url: '/v1/validate/name';
};

export type ValidateNameErrors = {
    /**
     * Validation error
     */
    400: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type ValidateNameError = ValidateNameErrors[keyof ValidateNameErrors];

export type ValidateNameResponses = {
    /**
     * Name validation result
     */
    200: {
        /**
         * Whether the name is valid
         */
        valid?: boolean;
        /**
         * Normalized name
         */
        normalized?: string;
        /**
         * List of validation reason codes
         */
        reason_codes?: Array<string>;
        request_id?: string;
    };
};

export type ValidateNameResponse = ValidateNameResponses[keyof ValidateNameResponses];

export type EvaluateOrderData = {
    body: {
        /**
         * Unique order identifier
         */
        order_id: string;
        customer: {
            /**
             * Customer email
             */
            email?: string;
            /**
             * Customer phone
             */
            phone?: string;
            /**
             * Customer first name
             */
            first_name?: string;
            /**
             * Customer last name
             */
            last_name?: string;
        };
        shipping_address: {
            /**
             * Street address line 1
             */
            line1?: string;
            /**
             * Street address line 2
             */
            line2?: string;
            /**
             * City
             */
            city?: string;
            /**
             * State or province
             */
            state?: string;
            /**
             * Postal code
             */
            postal_code?: string;
            /**
             * Two-letter country code
             */
            country?: string;
            /**
             * Latitude
             */
            lat?: number | null;
            /**
             * Longitude
             */
            lng?: number | null;
        };
        /**
         * Order total amount
         */
        total_amount: number;
        /**
         * Currency code (e.g., USD, EUR)
         */
        currency: string;
        /**
         * Payment method
         */
        payment_method?: 'card' | 'cod' | 'bank_transfer';
    };
    path?: never;
    query?: never;
    url: '/v1/orders/evaluate';
};

export type EvaluateOrderErrors = {
    /**
     * Validation error
     */
    400: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type EvaluateOrderError = EvaluateOrderErrors[keyof EvaluateOrderErrors];

export type EvaluateOrderResponses = {
    /**
     * Order evaluation results
     */
    200: {
        /**
         * Order ID
         */
        order_id?: string;
        /**
         * Risk score (0-100)
         */
        risk_score?: number;
        /**
         * Recommended action
         */
        action?: 'approve' | 'hold' | 'block';
        /**
         * Order tags
         */
        tags?: Array<string>;
        /**
         * List of reason codes
         */
        reason_codes?: Array<string>;
        customer_dedupe?: {
            matches?: Array<{
                id?: string;
                similarity_score?: number;
                match_type?: string;
                data?: {
                    [key: string]: unknown;
                };
            }>;
            suggested_action?: 'create_new' | 'merge_with' | 'review';
            canonical_id?: string | null;
        };
        address_dedupe?: {
            matches?: Array<{
                id?: string;
                similarity_score?: number;
                match_type?: string;
                data?: {
                    [key: string]: unknown;
                };
            }>;
            suggested_action?: 'create_new' | 'merge_with' | 'review';
            canonical_id?: string | null;
        };
        validations?: {
            email?: {
                /**
                 * Whether the validation passed
                 */
                valid?: boolean;
                /**
                 * List of reason codes
                 */
                reason_codes?: Array<string>;
                /**
                 * Whether the result is disposable (for email)
                 */
                disposable?: boolean;
            };
            phone?: {
                /**
                 * Whether the validation passed
                 */
                valid?: boolean;
                /**
                 * List of reason codes
                 */
                reason_codes?: Array<string>;
                /**
                 * Whether the result is disposable (for email)
                 */
                disposable?: boolean;
            };
            address?: {
                /**
                 * Whether the address is valid
                 */
                valid?: boolean;
                /**
                 * List of reason codes
                 */
                reason_codes?: Array<string>;
                /**
                 * Whether the address is a P.O. Box
                 */
                po_box?: boolean;
                /**
                 * Whether postal code matches city
                 */
                postal_city_match?: boolean;
                /**
                 * Whether the address is within bounds
                 */
                in_bounds?: boolean;
            };
        };
        rules_evaluation?: {
            triggered_rules?: Array<{
                rule_id?: string;
                rule_name?: string;
                description?: string;
                action?: 'approve' | 'hold' | 'block';
                confidence_score?: number;
                reason?: string;
            }>;
            final_decision?: {
                action?: 'approve' | 'hold' | 'block' | 'review';
                confidence?: number;
                reasons?: Array<string>;
                risk_score?: number;
                risk_level?: string;
            } | null;
        };
        request_id?: string;
    };
};

export type EvaluateOrderResponse = EvaluateOrderResponses[keyof EvaluateOrderResponses];

export type VerifyPhoneOtpData = {
    body: {
        /**
         * Twilio Verify SID from validation response
         */
        verification_sid: string;
        /**
         * OTP code entered by user
         */
        code: string;
    };
    path?: never;
    query?: never;
    url: '/v1/verify/phone';
};

export type VerifyPhoneOtpErrors = {
    /**
     * Invalid OTP
     */
    400: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type VerifyPhoneOtpError = VerifyPhoneOtpErrors[keyof VerifyPhoneOtpErrors];

export type VerifyPhoneOtpResponses = {
    /**
     * OTP verification result
     */
    200: {
        /**
         * Whether OTP is valid
         */
        valid?: boolean;
        /**
         * List of reason codes
         */
        reason_codes?: Array<string>;
        request_id?: string;
    };
};

export type VerifyPhoneOtpResponse = VerifyPhoneOtpResponses[keyof VerifyPhoneOtpResponses];

export type GetLogsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by exact reason code
         */
        reason_code?: string;
        /**
         * Filter by exact endpoint
         */
        endpoint?: string;
        /**
         * Filter by HTTP status code
         */
        status?: number;
        /**
         * Number of logs to return
         */
        limit?: number;
        /**
         * Number of logs to skip
         */
        offset?: number;
    };
    url: '/v1/data/logs';
};

export type GetLogsErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type GetLogsError = GetLogsErrors[keyof GetLogsErrors];

export type GetLogsResponses = {
    /**
     * List of log entries
     */
    200: {
        data?: Array<{
            /**
             * Log entry ID
             */
            id?: string;
            /**
             * Log entry type
             */
            type?: string;
            /**
             * API endpoint
             */
            endpoint?: string;
            /**
             * List of reason codes
             */
            reason_codes?: Array<string>;
            /**
             * HTTP status code
             */
            status?: number;
            /**
             * Additional metadata
             */
            meta?: {
                [key: string]: unknown;
            };
            /**
             * Creation timestamp
             */
            created_at?: string;
        }>;
        /**
         * Next offset for pagination
         */
        next_cursor?: string | null;
        /**
         * Total number of matching logs
         */
        total_count?: number;
        request_id?: string;
    };
};

export type GetLogsResponse = GetLogsResponses[keyof GetLogsResponses];

export type GetUsageData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/data/usage';
};

export type GetUsageErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type GetUsageError = GetUsageErrors[keyof GetUsageErrors];

export type GetUsageResponses = {
    /**
     * Usage statistics
     */
    200: {
        /**
         * Time period
         */
        period?: string;
        totals?: {
            /**
             * Total validations
             */
            validations?: number;
            /**
             * Total orders
             */
            orders?: number;
        };
        by_day?: Array<{
            /**
             * Date
             */
            date?: string;
            /**
             * Validations for this day
             */
            validations?: number;
            /**
             * Orders for this day
             */
            orders?: number;
        }>;
        top_reason_codes?: Array<{
            /**
             * Reason code
             */
            code?: string;
            /**
             * Count
             */
            count?: number;
        }>;
        /**
         * Cache hit ratio percentage
         */
        cache_hit_ratio?: number;
        request_id?: string;
    };
};

export type GetUsageResponse = GetUsageResponses[keyof GetUsageResponses];

export type DeleteLogData = {
    body?: never;
    path: {
        /**
         * ID of the log entry to delete
         */
        id: string;
    };
    query?: never;
    url: '/v1/logs/{id}';
};

export type DeleteLogErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Log entry not found
     */
    404: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type DeleteLogError = DeleteLogErrors[keyof DeleteLogErrors];

export type DeleteLogResponses = {
    /**
     * Log entry deleted successfully
     */
    200: {
        /**
         * Success message
         */
        message?: string;
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type DeleteLogResponse = DeleteLogResponses[keyof DeleteLogResponses];

export type ListPersonalAccessTokensData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/pats';
};

export type ListPersonalAccessTokensErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type ListPersonalAccessTokensError = ListPersonalAccessTokensErrors[keyof ListPersonalAccessTokensErrors];

export type ListPersonalAccessTokensResponses = {
    /**
     * List of personal access tokens
     */
    200: {
        pats?: Array<{
            /**
             * Token ID
             */
            id?: string;
            /**
             * Public token identifier (last 4 chars shown)
             */
            token_id?: string;
            /**
             * Token name
             */
            name?: string;
            /**
             * Access scopes
             */
            scopes?: Array<string>;
            /**
             * Environment
             */
            env?: 'test' | 'live';
            /**
             * Last usage timestamp
             */
            last_used_at?: string | null;
            /**
             * Last usage IP
             */
            last_used_ip?: string | null;
            /**
             * Expiration date
             */
            expires_at?: string | null;
            /**
             * Whether token is disabled
             */
            disabled?: boolean;
            /**
             * Creation timestamp
             */
            created_at?: string;
        }>;
        request_id?: string;
    };
};

export type ListPersonalAccessTokensResponse = ListPersonalAccessTokensResponses[keyof ListPersonalAccessTokensResponses];

export type CreatePersonalAccessTokenData = {
    body: {
        /**
         * Token name
         */
        name: string;
        /**
         * Access scopes for the token (optional, defaults to basic read access)
         */
        scopes?: Array<'keys:read' | 'keys:write' | 'logs:read' | 'usage:read' | 'webhooks:manage' | 'connectors:manage' | 'pats:manage' | 'projects:manage' | 'rules:manage'> | null;
        /**
         * Environment for the token
         */
        env?: 'test' | 'live';
        /**
         * Optional expiration date
         */
        expires_at?: string | null;
        /**
         * Optional IP allowlist (CIDR notation)
         */
        ip_allowlist?: Array<string> | null;
        /**
         * Optional project restriction
         */
        project_id?: string | null;
    };
    path?: never;
    query?: never;
    url: '/v1/pats';
};

export type CreatePersonalAccessTokenErrors = {
    /**
     * Invalid input
     */
    400: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type CreatePersonalAccessTokenError = CreatePersonalAccessTokenErrors[keyof CreatePersonalAccessTokenErrors];

export type CreatePersonalAccessTokenResponses = {
    /**
     * Personal access token created successfully
     */
    201: {
        /**
         * The full PAT (shown only once)
         */
        token?: string;
        /**
         * Token identifier
         */
        token_id?: string;
        name?: string;
        scopes?: Array<string>;
        env?: string;
        expires_at?: string | null;
        created_at?: string;
        request_id?: string;
    };
};

export type CreatePersonalAccessTokenResponse = CreatePersonalAccessTokenResponses[keyof CreatePersonalAccessTokenResponses];

export type RevokePersonalAccessTokenData = {
    body?: never;
    path: {
        /**
         * Token ID to revoke
         */
        token_id: string;
    };
    query?: never;
    url: '/v1/pats/{token_id}';
};

export type RevokePersonalAccessTokenErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Personal access token not found
     */
    404: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type RevokePersonalAccessTokenError = RevokePersonalAccessTokenErrors[keyof RevokePersonalAccessTokenErrors];

export type RevokePersonalAccessTokenResponses = {
    /**
     * Personal access token revoked successfully
     */
    204: void;
};

export type RevokePersonalAccessTokenResponse = RevokePersonalAccessTokenResponses[keyof RevokePersonalAccessTokenResponses];

export type GetSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/settings';
};

export type GetSettingsErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type GetSettingsError = GetSettingsErrors[keyof GetSettingsErrors];

export type GetSettingsResponses = {
    /**
     * Tenant settings
     */
    200: {
        /**
         * Country-specific default settings
         */
        country_defaults?: {
            [key: string]: unknown;
        };
        /**
         * Formatting preferences
         */
        formatting?: {
            [key: string]: unknown;
        };
        /**
         * Risk assessment thresholds
         */
        risk_thresholds?: {
            [key: string]: unknown;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type GetSettingsResponse = GetSettingsResponses[keyof GetSettingsResponses];

export type UpdateSettingsData = {
    body: {
        /**
         * Country-specific default settings
         */
        country_defaults?: {
            [key: string]: unknown;
        };
        /**
         * Formatting preferences
         */
        formatting?: {
            [key: string]: unknown;
        };
        /**
         * Risk assessment thresholds
         */
        risk_thresholds?: {
            [key: string]: unknown;
        };
    };
    path?: never;
    query?: never;
    url: '/v1/settings';
};

export type UpdateSettingsErrors = {
    /**
     * Invalid input data
     */
    400: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type UpdateSettingsError = UpdateSettingsErrors[keyof UpdateSettingsErrors];

export type UpdateSettingsResponses = {
    /**
     * Settings updated successfully
     */
    200: {
        /**
         * Success message
         */
        message?: string;
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type UpdateSettingsResponse = UpdateSettingsResponses[keyof UpdateSettingsResponses];

export type EraseDataData = {
    body: {
        /**
         * Reason for data erasure (gdpr/ccpa)
         */
        reason: 'gdpr' | 'ccpa';
    };
    path?: never;
    query?: never;
    url: '/v1/data/erase';
};

export type EraseDataErrors = {
    /**
     * Invalid input data
     */
    400: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type EraseDataError = EraseDataErrors[keyof EraseDataErrors];

export type EraseDataResponses = {
    /**
     * Data erasure initiated
     */
    202: {
        /**
         * Confirmation message
         */
        message?: string;
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type EraseDataResponse = EraseDataResponses[keyof EraseDataResponses];

export type CreateCheckoutSessionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/billing/checkout';
};

export type CreateCheckoutSessionErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Rate limit exceeded
     */
    429: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type CreateCheckoutSessionError = CreateCheckoutSessionErrors[keyof CreateCheckoutSessionErrors];

export type CreateCheckoutSessionResponses = {
    /**
     * Checkout session created
     */
    200: {
        session_url?: string;
        session_id?: string;
        request_id?: string;
    };
};

export type CreateCheckoutSessionResponse = CreateCheckoutSessionResponses[keyof CreateCheckoutSessionResponses];

export type CreateCustomerPortalSessionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/billing/portal';
};

export type CreateCustomerPortalSessionErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * No billing account found
     */
    404: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Rate limit exceeded
     */
    429: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type CreateCustomerPortalSessionError = CreateCustomerPortalSessionErrors[keyof CreateCustomerPortalSessionErrors];

export type CreateCustomerPortalSessionResponses = {
    /**
     * Portal session created
     */
    200: {
        portal_url?: string;
        request_id?: string;
    };
};

export type CreateCustomerPortalSessionResponse = CreateCustomerPortalSessionResponses[keyof CreateCustomerPortalSessionResponses];

export type ListUsersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users';
};

export type ListUsersErrors = {
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type ListUsersError = ListUsersErrors[keyof ListUsersErrors];

export type ListUsersResponses = {
    /**
     * List of users
     */
    200: {
        data?: Array<{
            /**
             * User ID
             */
            id: string;
            /**
             * User email address
             */
            email: string;
            /**
             * User first name
             */
            first_name: string;
            /**
             * User last name
             */
            last_name: string;
            /**
             * Creation timestamp
             */
            created_at?: string;
            /**
             * Last update timestamp
             */
            updated_at?: string;
        }>;
        request_id?: string;
    };
};

export type ListUsersResponse = ListUsersResponses[keyof ListUsersResponses];

export type CreateUserData = {
    body: {
        /**
         * User email address
         */
        email: string;
        /**
         * User first name
         */
        first_name: string;
        /**
         * User last name
         */
        last_name: string;
        /**
         * User password (optional for admin creation)
         */
        password?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/users';
};

export type CreateUserErrors = {
    /**
     * Invalid input
     */
    400: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
    /**
     * Unauthorized
     */
    401: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type CreateUserError = CreateUserErrors[keyof CreateUserErrors];

export type CreateUserResponses = {
    /**
     * User created successfully
     */
    201: {
        /**
         * User ID
         */
        id: string;
        /**
         * User email address
         */
        email: string;
        /**
         * User first name
         */
        first_name: string;
        /**
         * User last name
         */
        last_name: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type CreateUserResponse = CreateUserResponses[keyof CreateUserResponses];

export type NormalizeAddressData = {
    body: {
        address: {
            line1: string;
            line2?: string;
            city: string;
            state?: string;
            postal_code: string;
            country: string;
        };
    };
    path?: never;
    query?: never;
    url: '/v1/normalize/address';
};

export type NormalizeAddressErrors = {
    /**
     * Bad request
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
    /**
     * Rate limit exceeded
     */
    429: {
        code?: 'LIMIT_EXCEEDED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type NormalizeAddressError = NormalizeAddressErrors[keyof NormalizeAddressErrors];

export type NormalizeAddressResponses = {
    /**
     * Successful normalization response
     */
    200: {
        normalized?: {
            line1?: string;
            line2?: string;
            city?: string;
            state?: string;
            postal_code?: string;
            country?: string;
        };
        request_id?: string;
    };
};

export type NormalizeAddressResponse = NormalizeAddressResponses[keyof NormalizeAddressResponses];

export type DedupeCustomerData = {
    body: {
        /**
         * Customer email
         */
        email: string;
        /**
         * Customer phone
         */
        phone?: string;
        /**
         * Customer first name
         */
        first_name: string;
        /**
         * Customer last name
         */
        last_name: string;
    };
    path?: never;
    query?: never;
    url: '/v1/dedupe/customer';
};

export type DedupeCustomerErrors = {
    /**
     * Bad request
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Rate limit exceeded
     */
    429: {
        code?: 'LIMIT_EXCEEDED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type DedupeCustomerError = DedupeCustomerErrors[keyof DedupeCustomerErrors];

export type DedupeCustomerResponses = {
    /**
     * Deduplication results
     */
    200: {
        matches?: Array<{
            /**
             * Customer ID
             */
            id?: string;
            /**
             * Similarity score (0-1)
             */
            similarity_score?: number;
            /**
             * Type of match
             */
            match_type?: 'exact_email' | 'exact_phone' | 'fuzzy_name';
            data?: {
                email?: string;
                phone?: string;
                first_name?: string;
                last_name?: string;
            };
        }>;
        /**
         * Suggested action
         */
        suggested_action?: 'create_new' | 'merge_with' | 'review';
        /**
         * Suggested canonical ID
         */
        canonical_id?: string | null;
        request_id?: string;
    };
};

export type DedupeCustomerResponse = DedupeCustomerResponses[keyof DedupeCustomerResponses];

export type DedupeAddressData = {
    body: {
        /**
         * Street address line 1
         */
        line1: string;
        /**
         * Street address line 2
         */
        line2?: string;
        /**
         * City
         */
        city: string;
        /**
         * State or province
         */
        state?: string;
        /**
         * Postal code
         */
        postal_code: string;
        /**
         * Two-letter country code
         */
        country: string;
    };
    path?: never;
    query?: never;
    url: '/v1/dedupe/address';
};

export type DedupeAddressErrors = {
    /**
     * Validation error
     */
    400: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type DedupeAddressError = DedupeAddressErrors[keyof DedupeAddressErrors];

export type DedupeAddressResponses = {
    /**
     * Deduplication results
     */
    200: {
        matches?: Array<{
            /**
             * Address ID
             */
            id?: string;
            /**
             * Similarity score (0-1)
             */
            similarity_score?: number;
            /**
             * Type of match
             */
            match_type?: 'exact_address' | 'exact_postal' | 'fuzzy_address';
            data?: {
                /**
                 * Street address line 1
                 */
                line1?: string;
                /**
                 * Street address line 2
                 */
                line2?: string;
                /**
                 * City
                 */
                city?: string;
                /**
                 * State or province
                 */
                state?: string;
                /**
                 * Postal code
                 */
                postal_code?: string;
                /**
                 * Two-letter country code
                 */
                country?: string;
                /**
                 * Latitude
                 */
                lat?: number | null;
                /**
                 * Longitude
                 */
                lng?: number | null;
            };
        }>;
        /**
         * Suggested action
         */
        suggested_action?: 'create_new' | 'merge_with' | 'review';
        /**
         * Suggested canonical ID
         */
        canonical_id?: string | null;
        request_id?: string;
    };
};

export type DedupeAddressResponse = DedupeAddressResponses[keyof DedupeAddressResponses];

export type MergeDeduplicatedData = {
    body: {
        /**
         * Type of records to merge
         */
        type: 'customer' | 'address';
        /**
         * IDs to merge
         */
        ids: Array<string>;
        /**
         * ID of canonical record to keep
         */
        canonical_id: string;
    };
    path?: never;
    query?: never;
    url: '/v1/dedupe/merge';
};

export type MergeDeduplicatedErrors = {
    /**
     * Validation error
     */
    400: {
        error?: {
            /**
             * Error code
             */
            code?: string;
            /**
             * Error message
             */
            message?: string;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type MergeDeduplicatedError = MergeDeduplicatedErrors[keyof MergeDeduplicatedErrors];

export type MergeDeduplicatedResponses = {
    /**
     * Merge result
     */
    200: {
        /**
         * Whether merge was successful
         */
        success?: boolean;
        /**
         * Number of records merged
         */
        merged_count?: number;
        /**
         * ID of canonical record
         */
        canonical_id?: string;
        request_id?: string;
    };
};

export type MergeDeduplicatedResponse = MergeDeduplicatedResponses[keyof MergeDeduplicatedResponses];

export type BatchValidateData = {
    body: {
        /**
         * The type of data to validate
         */
        type: 'email' | 'phone' | 'address' | 'tax-id';
        /**
         * Array of items to validate (1-10,000 items)
         */
        data: Array<{
            [key: string]: unknown;
        }>;
    };
    path?: never;
    query?: never;
    url: '/v1/batch/validate';
};

export type BatchValidateErrors = {
    /**
     * Bad request - invalid input data or exceeds item limit
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
    /**
     * Rate limit exceeded
     */
    429: {
        code?: 'LIMIT_EXCEEDED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type BatchValidateError = BatchValidateErrors[keyof BatchValidateErrors];

export type BatchValidateResponses = {
    /**
     * Batch validation job accepted and queued for processing
     */
    202: {
        /**
         * Unique job identifier for tracking progress and retrieving results
         */
        job_id?: string;
        /**
         * Job status (always 'pending' when job is created)
         */
        status?: 'pending';
        /**
         * Request identifier for debugging
         */
        request_id?: string;
    };
};

export type BatchValidateResponse = BatchValidateResponses[keyof BatchValidateResponses];

export type BatchDedupeData = {
    body: {
        /**
         * The type of data to deduplicate
         */
        type: 'customers' | 'addresses';
        /**
         * Array of items to deduplicate (1-10,000 items)
         */
        data: Array<{
            [key: string]: unknown;
        }>;
    };
    path?: never;
    query?: never;
    url: '/v1/batch/dedupe';
};

export type BatchDedupeErrors = {
    /**
     * Bad request - invalid input data or exceeds item limit
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
    /**
     * Rate limit exceeded
     */
    429: {
        code?: 'LIMIT_EXCEEDED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type BatchDedupeError = BatchDedupeErrors[keyof BatchDedupeErrors];

export type BatchDedupeResponses = {
    /**
     * Batch deduplication job accepted and queued for processing
     */
    202: {
        /**
         * Unique job identifier for tracking progress and retrieving results
         */
        job_id?: string;
        /**
         * Job status (always 'pending' when job is created)
         */
        status?: 'pending';
        /**
         * Request identifier for debugging
         */
        request_id?: string;
    };
};

export type BatchDedupeResponse = BatchDedupeResponses[keyof BatchDedupeResponses];

export type BatchEvaluateOrdersData = {
    body: {
        orders: Array<{
            /**
             * Unique order identifier
             */
            order_id: string;
            /**
             * Customer email address for risk assessment
             */
            customer_email: string;
            /**
             * Customer phone number (optional, used for additional validation)
             */
            customer_phone?: string;
            /**
             * Order total amount in the specified currency
             */
            total_amount?: number;
            /**
             * Currency code (e.g., USD, EUR) - defaults to USD if not specified
             */
            currency?: string;
            /**
             * Comma-separated list of item names or SKUs in the order
             */
            items?: string;
            /**
             * Full shipping address for delivery risk assessment
             */
            shipping_address?: string;
        }>;
    };
    path?: never;
    query?: never;
    url: '/v1/batch/orders';
};

export type BatchEvaluateOrdersErrors = {
    /**
     * Bad request - missing required fields, invalid data, or exceeds order limit
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
    /**
     * Rate limit exceeded
     */
    429: {
        code?: 'LIMIT_EXCEEDED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type BatchEvaluateOrdersError = BatchEvaluateOrdersErrors[keyof BatchEvaluateOrdersErrors];

export type BatchEvaluateOrdersResponses = {
    /**
     * Batch order evaluation job accepted and queued for processing
     */
    202: {
        /**
         * Unique job identifier for tracking progress and retrieving results
         */
        job_id?: string;
        /**
         * Job status (always 'pending' when job is created)
         */
        status?: 'pending';
        /**
         * Request identifier for debugging
         */
        request_id?: string;
    };
};

export type BatchEvaluateOrdersResponse = BatchEvaluateOrdersResponses[keyof BatchEvaluateOrdersResponses];

export type GetJobStatusByIdData = {
    body?: never;
    path: {
        /**
         * Job ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/jobs/{id}';
};

export type GetJobStatusByIdErrors = {
    /**
     * Job not found
     */
    404: {
        error?: {
            code?: 'NOT_FOUND';
            /**
             * Error message
             */
            message?: string;
        };
    };
};

export type GetJobStatusByIdError = GetJobStatusByIdErrors[keyof GetJobStatusByIdErrors];

export type GetJobStatusByIdResponses = {
    /**
     * Job status information
     */
    200: {
        /**
         * Job ID
         */
        id?: string;
        /**
         * Current job status
         */
        status?: 'pending' | 'processing' | 'completed' | 'failed';
        /**
         * Job completion percentage
         */
        progress?: number;
        /**
         * Job result data, only included when status is 'completed'. Structure varies by job type - validation jobs return validation results per item, deduplication jobs return match suggestions per item.
         */
        result?: {
            [key: string]: unknown;
        } | null;
        /**
         * URL to download job result if applicable
         */
        result_url?: string | null;
        /**
         * Error message if job failed
         */
        error?: string | null;
        /**
         * Job creation timestamp
         */
        created_at?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
        request_id?: string;
    };
};

export type GetJobStatusByIdResponse = GetJobStatusByIdResponses[keyof GetJobStatusByIdResponses];

export type GetUserProjectsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/projects';
};

export type GetUserProjectsErrors = {
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type GetUserProjectsError = GetUserProjectsErrors[keyof GetUserProjectsErrors];

export type GetUserProjectsResponses = {
    /**
     * List of projects and plan information
     */
    200: {
        projects?: Array<{
            /**
             * Project ID
             */
            id?: string;
            /**
             * Project name
             */
            name?: string;
            /**
             * Project creation timestamp
             */
            created_at?: string;
        }>;
        plan?: {
            /**
             * Plan slug
             */
            slug?: string;
            /**
             * Maximum number of projects allowed
             */
            projectsLimit?: number;
            /**
             * Current number of projects
             */
            currentProjects?: number;
            /**
             * Whether user can create more projects
             */
            canCreateMore?: boolean;
        };
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type GetUserProjectsResponse = GetUserProjectsResponses[keyof GetUserProjectsResponses];

export type CreateProjectData = {
    body: {
        /**
         * Project name
         */
        name: string;
    };
    path?: never;
    query?: never;
    url: '/projects';
};

export type CreateProjectErrors = {
    /**
     * Invalid input
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type CreateProjectError = CreateProjectErrors[keyof CreateProjectErrors];

export type CreateProjectResponses = {
    /**
     * Project created successfully
     */
    201: {
        /**
         * Project ID
         */
        id?: string;
        /**
         * Project name
         */
        name?: string;
        /**
         * Project creation timestamp
         */
        created_at?: string;
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type CreateProjectResponse = CreateProjectResponses[keyof CreateProjectResponses];

export type DeleteProjectData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}';
};

export type DeleteProjectErrors = {
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
    /**
     * Project not found
     */
    404: {
        error?: {
            code?: 'NOT_FOUND';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Internal server error
     */
    500: {
        error?: {
            code?: 'INTERNAL_SERVER_ERROR';
            /**
             * Error message
             */
            message?: string;
        };
    };
};

export type DeleteProjectError = DeleteProjectErrors[keyof DeleteProjectErrors];

export type DeleteProjectResponses = {
    /**
     * Project deleted successfully
     */
    200: {
        /**
         * Success message
         */
        message?: string;
        /**
         * Request identifier
         */
        request_id?: string;
    };
};

export type DeleteProjectResponse = DeleteProjectResponses[keyof DeleteProjectResponses];

export type GetUserPlanData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/plan';
};

export type GetUserPlanErrors = {
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type GetUserPlanError = GetUserPlanErrors[keyof GetUserPlanErrors];

export type GetUserPlanResponses = {
    /**
     * User plan information
     */
    200: {
        /**
         * User ID
         */
        id?: string;
        /**
         * User email
         */
        email?: string;
        /**
         * Current plan details
         */
        plan?: {
            [key: string]: unknown;
        };
        /**
         * Number of validations used this month
         */
        monthlyValidationsUsed?: number;
        /**
         * Subscription status
         */
        subscriptionStatus?: string;
        /**
         * Trial end date if applicable
         */
        trialEndDate?: string | null;
        /**
         * Number of projects
         */
        projectsCount?: number;
    };
};

export type GetUserPlanResponse = GetUserPlanResponses[keyof GetUserPlanResponses];

export type UpdateUserPlanData = {
    body: {
        /**
         * Plan slug to update to
         */
        planSlug: 'free' | 'starter' | 'growth' | 'scale' | 'enterprise';
        /**
         * Days for trial period (optional)
         */
        trialDays?: number | null;
    };
    path?: never;
    query?: never;
    url: '/user/plan';
};

export type UpdateUserPlanErrors = {
    /**
     * Invalid plan slug
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
    /**
     * Internal server error
     */
    500: {
        error?: {
            code?: 'INTERNAL_SERVER_ERROR';
            /**
             * Error message
             */
            message?: string;
        };
    };
};

export type UpdateUserPlanError = UpdateUserPlanErrors[keyof UpdateUserPlanErrors];

export type UpdateUserPlanResponses = {
    /**
     * Plan updated successfully
     */
    200: {
        /**
         * User ID
         */
        id?: string;
        /**
         * User email
         */
        email?: string;
        /**
         * Current plan details
         */
        plan?: {
            [key: string]: unknown;
        };
        /**
         * Number of validations used this month
         */
        monthlyValidationsUsed?: number;
        /**
         * Subscription status
         */
        subscriptionStatus?: string;
        /**
         * Trial end date if applicable
         */
        trialEndDate?: string | null;
        /**
         * Number of projects
         */
        projectsCount?: number;
    };
};

export type UpdateUserPlanResponse = UpdateUserPlanResponses[keyof UpdateUserPlanResponses];

export type GetAvailablePlansData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/public/plans';
};

export type GetAvailablePlansErrors = {
    /**
     * Bad request
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
    /**
     * Rate limit exceeded
     */
    429: {
        code?: 'LIMIT_EXCEEDED';
        /**
         * Error message
         */
        message?: string;
    };
};

export type GetAvailablePlansError = GetAvailablePlansErrors[keyof GetAvailablePlansErrors];

export type GetAvailablePlansResponses = {
    /**
     * List of available plans
     */
    200: Array<{
        /**
         * Plan ID
         */
        id?: string;
        /**
         * Plan name
         */
        name?: string;
        /**
         * Plan slug
         */
        slug?: string;
        /**
         * Plan price
         */
        price?: number;
        /**
         * Monthly validation limit
         */
        validationsLimit?: number;
        /**
         * Project limit
         */
        projectsLimit?: number;
        /**
         * Plan features
         */
        features?: {
            [key: string]: unknown;
        };
    }>;
};

export type GetAvailablePlansResponse = GetAvailablePlansResponses[keyof GetAvailablePlansResponses];

export type EstimateRoiData = {
    body: {
        /**
         * Number of orders processed per month
         */
        orders_per_month: number;
        /**
         * Rate of orders that have issues (default 0.021)
         */
        issue_rate?: number;
        /**
         * Share of issues that trigger carrier fees (default 0.5)
         */
        carrier_fee_share?: number;
        /**
         * Average carrier correction fee in USD (default 23.75)
         */
        avg_correction_fee?: number;
        /**
         * Share of issues that require reshipping (default 0.1)
         */
        reship_share?: number;
        /**
         * Cost of reshipping in USD (default 10)
         */
        reship_cost?: number;
        /**
         * Rate at which Orbitcheck prevents issues (default 0.5)
         */
        prevention_rate?: number;
        /**
         * Currency code (default USD)
         */
        currency?: string;
    };
    path?: never;
    query?: never;
    url: '/public/roi/estimate';
};

export type EstimateRoiErrors = {
    /**
     * Bad request
     */
    400: {
        error?: {
            code?: 'INVALID_INPUT' | 'INVALID_PLAN';
            /**
             * Error message
             */
            message?: string;
        };
    };
};

export type EstimateRoiError = EstimateRoiErrors[keyof EstimateRoiErrors];

export type EstimateRoiResponses = {
    /**
     * ROI estimate result
     */
    200: {
        inputs?: {
            /**
             * Number of orders processed per month
             */
            orders_per_month?: number;
            /**
             * Rate of orders that have issues
             */
            issue_rate?: number;
            /**
             * Share of issues that trigger carrier fees
             */
            carrier_fee_share?: number;
            /**
             * Average carrier correction fee in USD
             */
            avg_correction_fee?: number;
            /**
             * Share of issues that require reshipping
             */
            reship_share?: number;
            /**
             * Cost of reshipping in USD
             */
            reship_cost?: number;
            /**
             * Rate at which Orbitcheck prevents issues
             */
            prevention_rate?: number;
            /**
             * Currency code
             */
            currency?: string;
        };
        estimates?: {
            /**
             * Estimated number of issues per month
             */
            issues_per_month?: number;
            /**
             * Average loss per issue in USD
             */
            loss_per_issue?: number;
            /**
             * Baseline monthly loss without Orbitcheck in USD
             */
            baseline_loss_per_month?: number;
            /**
             * Estimated monthly savings with Orbitcheck in USD
             */
            savings_per_month?: number;
        };
        meta?: {
            /**
             * Version of the ROI calculation model
             */
            model_version?: string;
            /**
             * Unique request identifier
             */
            request_id?: string;
        };
    };
};

export type EstimateRoiResponse = EstimateRoiResponses[keyof EstimateRoiResponses];

export type CheckValidationLimitsData = {
    body: {
        /**
         * Number of validations to check
         */
        count: number;
    };
    path?: never;
    query?: never;
    url: '/user/plan/usage/check';
};

export type CheckValidationLimitsErrors = {
    /**
     * Unauthorized
     */
    401: {
        code?: 'UNAUTHORIZED';
        /**
         * Error message
         */
        message?: string;
    };
    /**
     * Payment required (limit exceeded)
     */
    402: {
        code?: 'LIMIT_EXCEEDED';
        /**
         * Error message
         */
        message?: string;
    };
    /**
     * Internal server error
     */
    500: {
        error?: {
            code?: 'INTERNAL_SERVER_ERROR';
            /**
             * Error message
             */
            message?: string;
        };
    };
};

export type CheckValidationLimitsError = CheckValidationLimitsErrors[keyof CheckValidationLimitsErrors];

export type CheckValidationLimitsResponses = {
    /**
     * Usage check result
     */
    200: {
        /**
         * Whether the user can proceed with the requested validations
         */
        canProceed?: boolean;
        /**
         * Remaining validations in current period
         */
        remainingValidations?: number;
        /**
         * Whether overage is allowed on current plan
         */
        overageAllowed?: boolean;
        /**
         * Validations used this month
         */
        monthlyValidationsUsed?: number;
        /**
         * Plan validation limit
         */
        planValidationsLimit?: number;
    };
};

export type CheckValidationLimitsResponse = CheckValidationLimitsResponses[keyof CheckValidationLimitsResponses];
