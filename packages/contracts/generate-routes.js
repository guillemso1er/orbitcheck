#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';

// Load OpenAPI schema
const openapiPath = path.join(process.cwd(), 'openapi.yaml');
const openapiDoc = yaml.load(fs.readFileSync(openapiPath, 'utf8'));

// Initialize route objects
const DASHBOARD_ROUTES = {};
const MGMT_V1_ROUTES = {};
const API_V1_ROUTES = {};

// --- Helper function to create a clean constant name from the summary ---
const createConstantName = (summary) => {
  if (!summary) return 'UNKNOWN_ROUTE';
  return summary
    .replace(/[^a-zA-Z0-9\s]/g, '') // Allow letters, numbers, and spaces
    .trim()
    .replace(/\s+/g, '_')
    .toUpperCase();
};

// --- Process each path in the OpenAPI document ---
Object.entries(openapiDoc.paths).forEach(([path, methods]) => {
  Object.entries(methods).forEach(([method, methodConfig]) => {
    const { tags, summary } = methodConfig;
    const constantName = createConstantName(summary || `${method}_${path}`);
    
    if (!tags || tags.length === 0) {
      return; // Skip routes with no tags
    }

    const mainTag = tags[0];
    const formattedPath = path.replace(/\{([^}]+)\}/g, ':$1');

    switch (mainTag) {
      case 'UI Endpoints':
        DASHBOARD_ROUTES[constantName] = formattedPath;
        break;

      case 'Management API':
      case 'Runtime API':
        const segments = formattedPath.replace(/^\//, '').split('/');
        
        // --- STEP 1: Intelligently determine the GROUP KEY ---
        // If path is `/v1/rules`, the group segment is `rules`.
        // If path is `/rules`, the group segment is also `rules`.
        let groupSegment;
        if (segments.length > 1 && segments[0].toLowerCase() === 'v1') {
            groupSegment = segments[1];
        } else {
            groupSegment = segments[0];
        }

        if (!groupSegment) {
            console.warn(`[!] Skipping API path "${path}" as it lacks a resource segment for grouping.`);
            break;
        }
        
        const groupKey = groupSegment.toUpperCase().replace(/-/g, '_');
        
        // --- STEP 2: Explicitly ensure the FINAL PATH has the /v1 prefix ---
        const finalPath = formattedPath.startsWith('/v1') ? formattedPath : `/v1${formattedPath}`;
        
        const targetObject = mainTag === 'Management API' ? MGMT_V1_ROUTES : API_V1_ROUTES;

        if (!targetObject[groupKey]) {
          targetObject[groupKey] = {};
        }
        
        // Assign the correctly prefixed path
        targetObject[groupKey][constantName] = finalPath;
        break;
    }
  });
});

// --- Generate the TypeScript output ---
let output = `/**
 * Auto-generated route constants from OpenAPI schema
 * Generated at: ${new Date().toISOString()}
 * Do not edit this file manually - run this script to update
 */

`;

// --- Generate DASHBOARD_ROUTES ---
if (Object.keys(DASHBOARD_ROUTES).length > 0) {
    // Note: Renamed from DASHBOARD_ROUTES to match your desired output
    output += '// UI-only (session/cookies; unversioned)\n';
    output += 'export const DASHBOARD_ROUTES = {\n';
    for (const [key, value] of Object.entries(DASHBOARD_ROUTES)) {
      output += `  ${key}: '${value}',\n`;
    }
    output += `} as const;\n\n`;
}

// --- Generate MGMT_V1_ROUTES ---
if (Object.keys(MGMT_V1_ROUTES).length > 0) {
    output += '// Management API (versioned)\n';
    output += 'export const MGMT_V1_ROUTES = {\n';
    const sortedGroups = Object.keys(MGMT_V1_ROUTES).sort();
    for (const group of sortedGroups) {
      output += `  ${group}: {\n`;
      const routes = MGMT_V1_ROUTES[group];
      const sortedRoutes = Object.entries(routes).sort(([keyA], [keyB]) => keyA.localeCompare(keyB));
      for (const [key, value] of sortedRoutes) {
        output += `    ${key}: '${value}',\n`;
      }
      output += `  },\n`;
    }
    output += `} as const;\n\n`;
}

// --- Generate API_V1_ROUTES ---
if (Object.keys(API_V1_ROUTES).length > 0) {
    output += '// Runtime API\n';
    output += 'export const API_V1_ROUTES = {\n';
    const sortedGroups = Object.keys(API_V1_ROUTES).sort();
    for (const group of sortedGroups) {
      output += `  ${group}: {\n`;
      const routes = API_V1_ROUTES[group];
      const sortedRoutes = Object.entries(routes).sort(([keyA], [keyB]) => keyA.localeCompare(keyB));
      for (const [key, value] of sortedRoutes) {
        output += `    ${key}: '${value}',\n`;
      }
      output += `  },\n`;
    }
    output += `} as const;\n`;
}

// --- Write the generated constants to a file ---
const routesPath = path.join(process.cwd(), 'src', 'routes.ts');
fs.writeFileSync(routesPath, output.trim() + '\n');

console.log('✅ Route constants generated successfully!');
console.log(`📁 Updated: ${routesPath}`);