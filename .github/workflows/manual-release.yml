name: Manual Release (auto next version)

on:
    workflow_dispatch:
        inputs:
            bump:
                description: Which part to bump? (examples use "patch")
                required: false
                default: patch
                type: choice
                options: [patch, minor, major]
            prefix:
                description: Tag prefix
                required: false
                default: v
                type: string
            target:
                description: Target ref (branch, tag, or SHA). Defaults to this workflow's commit.
                required: false
                type: string

permissions:
    contents: write # needed to create tags and releases
    actions: read # needed to trigger other workflows

jobs:
    release:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout (fetch tags)
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Compute next version
              id: v
              shell: bash
              env:
                  BUMP: ${{ github.event.inputs.bump || 'patch' }}
                  PREFIX: ${{ github.event.inputs.prefix || 'v' }}
              run: |
                  set -euo pipefail

                  latest_tag=$(git tag -l "${PREFIX}[0-9]*.[0-9]*.[0-9]*" --sort=-version:refname | head -n 1 || true)

                  if [[ -z "${latest_tag}" ]]; then
                    base="0.0.0"
                  else
                    base="${latest_tag#${PREFIX}}"
                  fi

                  if [[ ! "$base" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
                    echo "Existing tag '$latest_tag' is not ${PREFIX}MAJOR.MINOR.PATCH"; exit 1
                  fi

                  IFS='.' read -r MAJOR MINOR PATCH <<< "$base"

                  case "$BUMP" in
                    patch) PATCH=$((PATCH+1));;
                    minor) MINOR=$((MINOR+1)); PATCH=0;;
                    major) MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0;;
                    *) echo "Unknown bump '$BUMP'"; exit 1;;
                  esac

                  next="${MAJOR}.${MINOR}.${PATCH}"
                  tag="${PREFIX}${next}"

                  echo "previous=${latest_tag:-${PREFIX}0.0.0}" >> "$GITHUB_OUTPUT"
                  echo "version=$next" >> "$GITHUB_OUTPUT"
                  echo "tag=$tag" >> "$GITHUB_OUTPUT"
                  echo "Next tag: $tag (from ${latest_tag:-none})"

            - name: Configure Git identity
              run: |
                  git config user.name "github-actions[bot]"
                  git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

            - name: Create and push tag (annotated)
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  set -euo pipefail
                  tag="${{ steps.v.outputs.tag }}"

                  # Resolve target: input -> repo default branch -> current commit
                  target_input="${{ github.event.inputs.target || '' }}"
                  if [ -n "$target_input" ]; then
                      target="$target_input"
                  else
                      # Derive default branch reliably from remote
                      target="$(git remote show origin | sed -n '/HEAD branch/s/.*: //p')"
                      target="${target:-main}"
                  fi

                  echo "Target to tag: $target"
                  git fetch --prune --tags origin "+refs/heads/*:refs/remotes/origin/*" >/dev/null
                  git fetch --tags origin >/dev/null

                  # Resolve commit for target (branch, tag, or SHA)
                  if git show-ref --verify --quiet "refs/remotes/origin/${target}"; then
                      commit="$(git rev-parse "refs/remotes/origin/${target}")"
                  else
                      commit="$(git rev-parse "${target}")" || true
                  fi
                  if [ -z "${commit:-}" ]; then
                      echo "::error title=Invalid target::Target '$target' not found."
                      exit 1
                  fi

                  # Create annotated tag locally if missing
                  if git rev-parse -q --verify "refs/tags/$tag" >/dev/null; then
                      echo "Tag $tag already exists locally."
                  else
                      git tag -a "$tag" -m "Release $tag" "$commit"
                  fi

                  # Push tag if not present on origin (this is what triggers your deploy workflow)
                  if git ls-remote --tags origin "refs/tags/$tag" | grep -q .; then
                      echo "Tag $tag already exists on origin."
                  else
                      git push origin "refs/tags/$tag"
                      echo "Pushed tag $tag -> $commit"
                  fi

            - name: Create GitHub release (uses existing tag)
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  set -euo pipefail
                  tag="${{ steps.v.outputs.tag }}"

                  if gh release view "$tag" >/dev/null 2>&1; then
                      echo "Release $tag already exists; nothing to do."
                      exit 0
                  fi

                  gh release create "$tag" \
                      --title "$tag" \
                      --generate-notes

            - name: Trigger Deploy workflow (workflow_dispatch)
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  set -euo pipefail
                  tag="${{ steps.v.outputs.tag }}"

                  # Choose one of the two forms below:

                  wf_file=".github/workflows/ci-cd.yml"
                  gh workflow run "$wf_file" --ref main -f version="$tag" -f force_deploy=true
