#!/usr/bin/env bash

set -euo pipefail

# ============================================================================
# Configuration
# ============================================================================
readonly SCRIPT_NAME="$(basename "$0")"
readonly BASE="${INFISICAL_SITE_URL:-http://localhost:8085}"
readonly ADMIN_EMAIL="${INFISICAL_ADMIN_EMAIL:-admin@orbicheck.local}"
readonly ADMIN_PASSWORD="${INFISICAL_ADMIN_PASSWORD:-AdminPass123!}"
readonly ORG_NAME="${INFISICAL_ORG:-orbicheck}"
readonly PROJECT_NAME="${INFISICAL_PROJECT:-orbicheck}"
readonly IDENTITY_NAME="${INFISICAL_IDENTITY:-orbicheck-reader}"
readonly TOKEN_TTL="${INFISICAL_TOKEN_TTL:-3600}"  # access token TTL (seconds)
readonly UA_SECRET_TTL="${INFISICAL_UA_SECRET_TTL:-0}" # 0 => non-expiring client secret (if supported)
readonly MAX_RETRIES=3
readonly RETRY_DELAY=2
readonly ADMIN_TOKEN_ENV="${INFISICAL_ADMIN_TOKEN:-${INFISICAL_TOKEN:-}}"

# UA credentials (can be provided via env or read from file later)
UA_CLIENT_ID="${INFISICAL_UA_CLIENT_ID:-${INFISICAL_CLIENT_ID:-}}"
UA_CLIENT_SECRET="${INFISICAL_UA_CLIENT_SECRET:-${INFISICAL_CLIENT_SECRET:-}}"

# Script location and UA credentials file
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]:-$0}")" && pwd)"
readonly UA_CRED_FILE_DEFAULT="$SCRIPT_DIR/.${IDENTITY_NAME}.ua.env"
readonly UA_CRED_FILE="${INFISICAL_UA_CRED_FILE:-$UA_CRED_FILE_DEFAULT}"

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# ============================================================================
# Logging Functions
# ============================================================================
log_info()    { echo -e "${BLUE}[INFO]${NC} $*" >&2; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $*" >&2; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $*" >&2; }
log_error()   { echo -e "${RED}[ERROR]${NC} $*" >&2; }
die() { log_error "$@"; exit 1; }

# ============================================================================
# Utility Functions
# ============================================================================
install_dependencies() {
  if ! command -v jq >/dev/null 2>&1 || ! command -v curl >/dev/null 2>&1; then
    log_info "Installing required packages..."
    apk add --no-cache jq curl &>/dev/null || {
      apt-get update && apt-get install -y jq curl
    } || die "Failed to install dependencies"
  fi
}

retry_api_call() {
  local retries=$1; shift
  local count=0
  local output
  until [ $count -ge $retries ]; do
    if output=$("$@" 2>&1); then
      echo "$output"
      return 0
    fi
    count=$((count + 1))
    [ $count -lt $retries ] && {
      log_warning "API call failed, retrying in ${RETRY_DELAY}s... (attempt $((count + 1))/$retries)"
      sleep $RETRY_DELAY
    }
  done
  return 1
}

wait_for_service() {
  local url=$1
  local timeout=${2:-90}
  local elapsed=0

  log_info "Waiting for Infisical to be ready at $url..."
  while [ $elapsed -lt $timeout ]; do
    if curl -sf "$url/api/status" >/dev/null 2>&1; then
      log_success "Infisical is ready!"
      return 0
    fi
    sleep 2
    elapsed=$((elapsed + 2))
    echo -n "." >&2
  done
  echo >&2
  die "Timeout waiting for Infisical to be ready"
}

validate_json() {
  local json=$1
  local field=$2
  echo "$json" | jq -e ".$field" >/dev/null 2>&1
}

# ============================================================================
# UA Credential Helpers (file I/O)
# ============================================================================
load_ua_creds_from_file() {
  # Load UA_CLIENT_ID / UA_CLIENT_SECRET from file if not already set via env
  if { [ -z "${UA_CLIENT_ID:-}" ] || [ -z "${UA_CLIENT_SECRET:-}" ]; } && [ -f "$UA_CRED_FILE" ]; then
    log_info "Loading Universal Auth credentials from $UA_CRED_FILE"
    # shellcheck disable=SC1090,SC1091
    set +u
    . "$UA_CRED_FILE"
    set -u
    # Prefer vars from file only if still missing
    UA_CLIENT_ID="${UA_CLIENT_ID:-${INFISICAL_CLIENT_ID:-}}"
    UA_CLIENT_SECRET="${UA_CLIENT_SECRET:-${INFISICAL_CLIENT_SECRET:-}}"
  fi
}

save_ua_creds_to_file() {
  local client_id=$1
  local client_secret=$2
  umask 077
  cat > "$UA_CRED_FILE" <<EOF
# Generated by $SCRIPT_NAME on $(date -u +'%Y-%m-%dT%H:%M:%SZ')
# Universal Auth credentials for identity: $IDENTITY_NAME
INFISICAL_CLIENT_ID=$client_id
INFISICAL_CLIENT_SECRET=$client_secret
EOF
  chmod 600 "$UA_CRED_FILE" || true
  log_success "Saved Universal Auth credentials to $UA_CRED_FILE"
}

# ============================================================================
# Core Functions
# ============================================================================

bootstrap_or_login() {
  log_info "Bootstrapping (or falling back if already initialized)..."

  # build payload safely
  local payload
  payload=$(jq -n --arg email "$ADMIN_EMAIL" --arg password "$ADMIN_PASSWORD" --arg organization "$ORG_NAME" \
    '{email:$email,password:$password,organization:$organization}')

  # capture both body and HTTP code
  local resp http
  resp=$(curl -sS -w "\n%{http_code}" -X POST "$BASE/api/v1/admin/bootstrap" \
           -H "Content-Type: application/json" -d "$payload") || true
  http="${resp##*$'\n'}"
  resp="${resp%$'\n'*}"

  if [ "$http" = "200" ]; then
    ADMIN_TOKEN=$(echo "$resp" | jq -r '.identity.credentials.token // .token // .accessToken // empty')
    ORG_ID=$(echo "$resp" | jq -r '.organization.id')
    [ -z "${ADMIN_TOKEN:-}" ] && die "Bootstrap succeeded but admin token missing"
    [ -z "${ORG_ID:-}" ] && die "Bootstrap succeeded but organization ID missing"
    log_success "Bootstrapped instance and obtained admin token."
    return 0
  fi

  # If already initialized, fall back to token/UA
  if echo "$resp" | grep -qi "already been set up"; then
    log_warning "Instance already initialized; falling back to existing credentials..."
  else
    log_warning "Bootstrap returned HTTP $http; falling back to existing credentials..."
  fi

  # 1) Use admin token from env if present
  if [ -n "${ADMIN_TOKEN_ENV:-}" ]; then
    ADMIN_TOKEN="$ADMIN_TOKEN_ENV"
    log_info "Using admin token from environment."
  # 2) Or perform UA login if clientId/secret provided (via env or file)
  else
    load_ua_creds_from_file
    if [ -n "${UA_CLIENT_ID:-}" ] && [ -n "${UA_CLIENT_SECRET:-}" ]; then
      log_info "Exchanging Universal Auth credentials for an access token..."
      local ua_login
      ua_login=$(curl -sS -X POST "$BASE/api/v1/auth/universal-auth/login" \
        -H "Content-Type: application/json" \
        -d "$(jq -n --arg id "$UA_CLIENT_ID" --arg secret "$UA_CLIENT_SECRET" '{clientId:$id,clientSecret:$secret}')" )
      ADMIN_TOKEN=$(echo "$ua_login" | jq -r '.accessToken // empty')
      [ -z "${ADMIN_TOKEN:-}" ] && die "UA login failed; check clientId/clientSecret."
    else
      die "Instance already initialized. Provide INFISICAL_ADMIN_TOKEN (or INFISICAL_TOKEN) or Universal Auth creds (INFISICAL_UA_CLIENT_ID + INFISICAL_UA_CLIENT_SECRET, or INFISICAL_CLIENT_ID + INFISICAL_CLIENT_SECRET, or a UA credential file at $UA_CRED_FILE)."
    fi
  fi

  # Discover ORG_ID by searching identity by name (no orgId needed)
  local identities
  identities=$(
    retry_api_call "$MAX_RETRIES" curl -sf \
      -H "Authorization: Bearer $ADMIN_TOKEN" \
      -H "Content-Type: application/json" \
      -X POST \
      -d "$(jq -n --arg name "$IDENTITY_NAME" '{limit:50, search:{name:$name}}')" \
      "$BASE/api/v1/identities/search"
  ) || die "Failed to search identities"

  local identity_id
  identity_id=$(
    jq -r --arg name "$IDENTITY_NAME" \
      '.identities[] | select(.identity.name==$name) | .id' \
      <<<"$identities" | head -n1
  )
  [ -z "${identity_id:-}" ] && die "Identity '$IDENTITY_NAME' not found with provided credentials."

  # Prefer orgId directly from the search result (present at the top-level)
  ORG_ID=$(
    jq -r --arg name "$IDENTITY_NAME" \
      '.identities[] | select(.identity.name==$name) | .orgId' \
      <<<"$identities" | head -n1
  )

  # Fallback: fetch identity details by ID and read .identity.orgId
  if [ -z "${ORG_ID:-}" ]; then
    local identity_details
    identity_details=$(
      retry_api_call "$MAX_RETRIES" curl -sf \
        -H "Authorization: Bearer $ADMIN_TOKEN" \
        "$BASE/api/v1/identities/$identity_id"
    ) || die "Failed to fetch identity details"
    ORG_ID=$(jq -r '.identity.orgId // empty' <<<"$identity_details")
  fi

  [ -z "${ORG_ID:-}" ] && die "Organization ID not found for identity '$IDENTITY_NAME'."
  echo "Using ORG_ID=$ORG_ID"
}

ensure_project() {
  log_info "Checking for project '$PROJECT_NAME'..."

  local projects_response
  projects_response=$(retry_api_call $MAX_RETRIES curl -sf \
    -H "Authorization: Bearer $ADMIN_TOKEN" \
    "$BASE/api/v1/projects") || die "Failed to fetch projects"

  echo "$projects_response" >&2 

  PROJECT_ID=$(
    echo "$projects_response" | jq -r \
      --arg name "$PROJECT_NAME" \
      '.projects[] 
        | select((.name // .projectName) == $name) 
        | (.id // .projectId // .workspaceId)' \
      | head -n1
  )

  if [ -z "$PROJECT_ID" ]; then
    log_info "Creating project '$PROJECT_NAME'..."

    # New API shape first: { projectName, orgId }
    local payload resp http body
    payload=$(jq -n \
      --arg name "$PROJECT_NAME" \
      --arg org "$ORG_ID" \
      --arg desc "Managed by $SCRIPT_NAME" \
      '{projectName:$name, orgId:$org, description:$desc}')

    # Capture body + HTTP status (don't use -f so we can read 4xx/5xx)
    resp=$(curl -sS -w "\n%{http_code}" -X POST "$BASE/api/v1/projects" \
      -H "Authorization: Bearer $ADMIN_TOKEN" \
      -H "Content-Type: application/json" \
      -d "$payload") || true
    http="${resp##*$'\n'}"
    body="${resp%$'\n'*}"

    # If not 2xx, try legacy shape: { name, organizationId }
    if [[ "$http" != 2* ]]; then
      log_warning "Create project failed with HTTP $http. Retrying with legacy payload shape..."
      payload=$(jq -n \
        --arg name "$PROJECT_NAME" \
        --arg org "$ORG_ID" \
        --arg desc "Managed by $SCRIPT_NAME" \
        '{name:$name, organizationId:$org, description:$desc}')

      resp=$(curl -sS -w "\n%{http_code}" -X POST "$BASE/api/v1/projects" \
        -H "Authorization: Bearer $ADMIN_TOKEN" \
        -H "Content-Type: application/json" \
        -d "$payload") || true
      http="${resp##*$'\n'}"
      body="${resp%$'\n'*}"
    fi

    if [[ "$http" != 2* ]]; then
      die "Failed to create project (HTTP $http): $body"
    fi

    PROJECT_ID=$(echo "$body" | jq -r '.project.id // .id // .projectId // .workspace.id // .workspaceId // empty')
    [ -z "$PROJECT_ID" ] && die "Project creation response missing ID. Body: $body"

    log_success "Project created with ID: $PROJECT_ID"
  else
    log_info "Project exists with ID: $PROJECT_ID"
  fi
}

ensure_identity_universal_auth() {
  # usage: ensure_identity_universal_auth [force_secret_rotation]
  # force_secret_rotation: "force" or empty
  local force_rotate="${1:-}"

  log_info "Ensuring Universal Auth is configured for identity '$IDENTITY_NAME' ($IDENTITY_ID)..."

  # Try to obtain current UA clientId (if any)
  local ua_check client_id
  ua_check=$(
    retry_api_call "$MAX_RETRIES" curl -sf \
      "$BASE/api/v1/auth/universal-auth/identities/$IDENTITY_ID" \
      -H "Authorization: Bearer $ADMIN_TOKEN"
  ) || ua_check='{}'

  client_id=$(echo "$ua_check" | jq -r '.identityUniversalAuth.clientId // .clientId // empty')

  if [ -z "${client_id:-}" ]; then
    log_info "Attaching Universal Auth to identity..."
    retry_api_call $MAX_RETRIES curl -sf -X POST \
      "$BASE/api/v1/auth/universal-auth/identities/$IDENTITY_ID" \
      -H "Authorization: Bearer $ADMIN_TOKEN" \
      -H "Content-Type: application/json" \
      -d "$(jq -n --arg ttl "$TOKEN_TTL" '{
            clientSecretTrustedIps: [{ipAddress:"0.0.0.0/0"},{ipAddress:"::/0"}],
            accessTokenTTL: ($ttl|tonumber)
          }')" >/dev/null \
      || die "Failed to attach Universal Auth to identity"

    ua_check=$(
      retry_api_call "$MAX_RETRIES" curl -sf \
        "$BASE/api/v1/auth/universal-auth/identities/$IDENTITY_ID" \
        -H "Authorization: Bearer $ADMIN_TOKEN"
    ) || die "Failed to verify Universal Auth configuration"
    client_id=$(echo "$ua_check" | jq -r '.identityUniversalAuth.clientId // .clientId // empty')
  fi

  [ -z "${client_id:-}" ] && die "Failed to determine clientId for identity"

  # Always use the server clientId
  UA_CLIENT_ID="$client_id"

  # Load any existing creds from file (may set INFISICAL_CLIENT_SECRET)
  load_ua_creds_from_file

  # Decide if we must create/rotate secret
  local need_secret=0
  if [ -n "$force_rotate" ]; then
    need_secret=1
  elif [ -z "${UA_CLIENT_SECRET:-}" ]; then
    need_secret=1
  elif [ ! -f "$UA_CRED_FILE" ]; then
    need_secret=1
  fi

  if [ "$need_secret" -eq 1 ]; then
    log_info "Creating client secret (ttl=${UA_SECRET_TTL}s; 0 => omit ttl)..."
    local secret_response
    secret_response=$(retry_api_call $MAX_RETRIES curl -sf -X POST \
      "$BASE/api/v1/auth/universal-auth/identities/$IDENTITY_ID/client-secrets" \
      -H "Authorization: Bearer $ADMIN_TOKEN" \
      -H "Content-Type: application/json" \
      -d "$(jq -n --arg desc "Persistent secret for $IDENTITY_NAME (generated by $SCRIPT_NAME)" --arg ttl "$UA_SECRET_TTL" '
            ($ttl|tonumber) as $t
            | { description: $desc, numUsesLimit: 0 }
            + (if $t > 0 then { ttl: $t } else {} end)
          ')") \
      || die "Failed to create client secret"

    UA_CLIENT_SECRET=$(echo "$secret_response" | jq -r '.clientSecret // empty')
    [ -z "${UA_CLIENT_SECRET:-}" ] && die "Client secret missing in response"

    save_ua_creds_to_file "$UA_CLIENT_ID" "$UA_CLIENT_SECRET"
  else
    log_info "Using existing client secret from $UA_CRED_FILE (or env)"
  fi
}
create_read_only_identity() {
  log_info "Setting up read-only machine identity..."

  local identities_response
  identities_response=$(retry_api_call $MAX_RETRIES curl -sf \
    -H "Authorization: Bearer $ADMIN_TOKEN" \
    "$BASE/api/v1/identities?orgId=$ORG_ID") || die "Failed to fetch identities"

  IDENTITY_ID=$(echo "$identities_response" | jq -r ".identities[] | select(.name==\"$IDENTITY_NAME\") | .id" | head -n1)

  if [ -z "$IDENTITY_ID" ]; then
    log_info "Creating machine identity '$IDENTITY_NAME'..."

    local identity_response
    identity_response=$(retry_api_call $MAX_RETRIES curl -sf -X POST "$BASE/api/v1/identities" \
      -H "Authorization: Bearer $ADMIN_TOKEN" \
      -H "Content-Type: application/json" \
      -d "{\"name\":\"$IDENTITY_NAME\",\"organizationId\":\"$ORG_ID\"}") || die "Failed to create identity"

    IDENTITY_ID=$(echo "$identity_response" | jq -r '.identity.id // .id')
    [ -z "$IDENTITY_ID" ] && die "Identity creation response missing ID"

    log_success "Identity created with ID: $IDENTITY_ID"
  else
    log_info "Identity exists with ID: $IDENTITY_ID"
  fi

  # NEW: Ensure UA is attached and credentials are saved to file
  ensure_identity_universal_auth
}

assign_read_only_role() {
  log_info "Configuring read-only permissions..."

  local roles_response
  roles_response=$(retry_api_call $MAX_RETRIES curl -sf \
    -H "Authorization: Bearer $ADMIN_TOKEN" \
    "$BASE/api/v1/projects/$PROJECT_ID/roles") || die "Failed to fetch project roles"

  # Prefer project_viewer; fallback to viewer/read; then pick least privileged
  local role_slug
  role_slug=$(echo "$roles_response" | jq -r '.roles[] | select(.slug=="project_viewer") | .slug' | head -n1)
  if [ -z "$role_slug" ]; then
    role_slug=$(echo "$roles_response" | jq -r '.roles[] | select(.slug | test("viewer|read"; "i")) | .slug' | head -n1)
  fi
  if [ -z "$role_slug" ]; then
    role_slug=$(echo "$roles_response" | jq -r '.roles | sort_by((.permissions // []) | length) | .[0].slug')
  fi
  [ -z "$role_slug" ] && die "No suitable read-only role found"
  log_info "Using role: $role_slug"

  # Check existing membership
  local memberships_response
  memberships_response=$(retry_api_call $MAX_RETRIES curl -sf \
    -H "Authorization: Bearer $ADMIN_TOKEN" \
    "$BASE/api/v1/projects/$PROJECT_ID/identity-memberships") || die "Failed to fetch memberships"

  local is_member
  is_member=$(echo "$memberships_response" | jq -r ".identityMemberships[] | select(.identity.id==\"$IDENTITY_ID\") | .id" | head -n1)

  if [ -z "$is_member" ]; then
    log_info "Adding identity to project with read-only access..."

    retry_api_call $MAX_RETRIES curl -sf -X POST \
    "$BASE/api/v1/projects/$PROJECT_ID/identity-memberships/$IDENTITY_ID" \
    -H "Authorization: Bearer $ADMIN_TOKEN" \
    -H "Content-Type: application/json" \
    -d "{\"roles\":[{\"role\":\"$role_slug\",\"isTemporary\":false}]}" >/dev/null \
    || die "Failed to add identity to project"

    log_success "Identity added to project with read-only access"
  else
    log_info "Identity already has project access"
  fi
}

generate_temporary_token() {
  log_info "Generating access token using Universal Auth credentials..."

  # Always ensure UA is attached and we have the correct clientId
  ensure_identity_universal_auth

  # Load credentials (file may have just been written)
  load_ua_creds_from_file
  [ -z "${UA_CLIENT_ID:-}" ] && die "UA clientId missing"
  [ -z "${UA_CLIENT_SECRET:-}" ] && die "UA clientSecret missing"

  # Try login
  local resp http body
  resp=$(curl -sS -w "\n%{http_code}" -X POST \
    "$BASE/api/v1/auth/universal-auth/login" \
    -H "Content-Type: application/json" \
    -d "$(jq -n --arg id "$UA_CLIENT_ID" --arg secret "$UA_CLIENT_SECRET" '{clientId:$id, clientSecret:$secret}')" ) || true
  http="${resp##*$'\n'}"
  body="${resp%$'\n'*}"

  if [[ "$http" == 2* ]]; then
    ACCESS_TOKEN=$(echo "$body" | jq -r '.accessToken // empty')
    [ -z "$ACCESS_TOKEN" ] && die "UA login 2xx but accessToken missing. Body: $body"
    log_success "Access token generated"
    return
  fi

  # If invalid credentials, rotate secret once and retry
  if [ "$http" = "401" ]; then
    log_warning "UA login failed with 401. Rotating client secret and retrying..."
    ensure_identity_universal_auth "force"

    # Reload after rotation
    load_ua_creds_from_file

    resp=$(curl -sS -w "\n%{http_code}" -X POST \
      "$BASE/api/v1/auth/universal-auth/login" \
      -H "Content-Type: application/json" \
      -d "$(jq -n --arg id "$UA_CLIENT_ID" --arg secret "$UA_CLIENT_SECRET" '{clientId:$id, clientSecret:$secret}')" ) || true
    http="${resp##*$'\n'}"
    body="${resp%$'\n'*}"

    if [[ "$http" == 2* ]]; then
      ACCESS_TOKEN=$(echo "$body" | jq -r '.accessToken // empty')
      [ -z "$ACCESS_TOKEN" ] && die "UA login 2xx but accessToken missing. Body: $body"
      log_success "Access token generated after secret rotation"
      return
    fi
  fi

  die "Failed to obtain access token (HTTP $http): $body"
}

# ============================================================================
# Main Execution
# ============================================================================
main() {
  install_dependencies
  wait_for_service "$BASE"
  bootstrap_or_login
  ensure_project
  create_read_only_identity
  assign_read_only_role
  generate_temporary_token

  # Output for consumers: "<access_token> <project_id> <admin_token>"
  echo "$ACCESS_TOKEN $PROJECT_ID $ADMIN_TOKEN"
}

main "$@"